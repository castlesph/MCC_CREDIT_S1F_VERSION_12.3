#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctosapi.h>
#include <ctype.h>
#include <EMVAPLib.h>
#include <EMVLib.h>

#include "../Includes/wub_lib.h"
#include "../Includes/myEZLib.h"
#include "../Includes/msg.h"

#include "Print.h"
#include "../FileModule/myFileFunc.h"
#include "../UI/Display.h"
#include "../Includes/POSTypedef.h"
#include "..\Includes\CTOSInput.h"
#include "../accum/accum.h"
#include "../DataBase/DataBaseFunc.h"
#include "..\debug\debug.h"
#include "..\Includes\Showbmp.h"
#include "..\Includes\POSHost.h"
#include "..\Includes\POSTrans.h"
#include "..\Includes\POSSetting.h"
#include "..\Includes\MultiApLib.h"
#include "..\Aptrans\MultiAptrans.h"
#include "..\Aptrans\MultiShareEMV.h"
#include "..\Includes\epad.h"
#include "..\Includes\PosLoyalty.h"
#include "..\POWRFAIL\POSPOWRFAIL.h"


const BYTE baPrinterBufferLogo_Single[]={ //Width=60, Height=49
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,                                         
                                                                                       
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0x60,0x30,0x18,0x18,0x8C,0xC4,0xC6,      
    0x66,0x66,0x22,0x22,0x22,0x22,0x22,0x62,0x66,0x46,0xC4,0x84,0x8C,0x18,0x10,0x30,      
    0x60,0xC0,0xC0,0xE0,0x38,0x0E,0x07,0x1E,0x38,0xE0,0x80,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,                                         
                                                                                       
    0x00,0x00,0x00,0x00,0xC0,0xF8,0x0E,0x03,0x81,0xF0,0x1C,0x0E,0x03,0xC1,0xF0,0xF8,      
    0x7C,0x3C,0x1C,0x1E,0x1E,0x1E,0xFE,0xFC,0xFC,0xFC,0xF8,0xF0,0xC1,0x83,0xCE,0x7C,      
    0x1C,0x07,0x81,0xE0,0x70,0x1C,0x0E,0x1C,0x70,0xC0,0x83,0x07,0x1C,0x70,0xE0,0x80,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,                                         
                                                                                      
    0x00,0x00,0x00,0x00,0x0F,0x7F,0xC0,0x00,0x03,0x3F,0xF0,0x80,0x00,0x0F,0x3F,0x7F,  
    0xFF,0xFC,0xFC,0xFC,0xFC,0xFE,0xF3,0xFB,0xFF,0xFF,0x7F,0x3F,0x0F,0x03,0x81,0xE0,  
    0x38,0x0E,0x03,0xC0,0xF0,0x1C,0x1C,0x38,0xE0,0x81,0x03,0x0E,0x38,0x70,0xC0,0x03,  
    0x0E,0x1C,0x70,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,  
    0xF0,0x78,0x18,0x18,0x0C,0x0C,0x0C,0x0C,0x08,0x18,0x38,0x30,0x00,0x00,0x00,0x00,  
    0x80,0x80,0xC0,0xC0,0xC0,0xC0,0x80,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x80,0xC0,  
    0xC0,0xC0,0xC0,0x80,0x00,0x00,0xC0,0xFC,0xFC,0xFC,0xC0,0xC0,0x00,0xFC,0xFC,0xFC,  
    0x00,0x00,0x00,0x80,0x80,0xC0,0xC0,0xC0,0xC0,0xC0,0x80,0x80,0x00,0x00,0x00,0x00,  
    0x80,0xC0,0xC0,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,  
    0x0C,0xFC,0xFC,0xFC,0x0C,0x0C,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xC0,0xC0,0xC0,  
    0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0xC0,0xC0,0xC0,0xC0,0xC0,0x80,  
    0x00,0x00,0x00,0x00,0xFC,0xFC,0xFC,0x80,0xC0,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,  
    0xC0,0xC0,0xC0,0xC0,0x80,0xC0,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x80,0x80,  
    0xC0,0xC0,0xC0,0xC0,0x80,0x80,0x00,0x00,0x00,0x00,0xFC,0xFC,0xFC,0x00,0x00,0x00,  
    0x00,0x80,0xC0,0xC0,0xC0,0xC0,0xC0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,  
    0xC0,0xC0,0xC0,0x80,0x80,0xC0,0xC0,0xC0,0x00,0x00,0x40,0xC0,0xC0,0x80,0x00,0x00,  
    0x00,0x00,0x80,0xC0,0xC0,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,  
    0xF0,0x78,0x18,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x38,0x30,0x00,0x00,0x00,0x00,  
    0x80,0x80,0xC0,0xC0,0xC0,0xC0,0xC0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
    0x00,0xFC,0xFC,0xFC,0x00,0x00,0x00,0x00,0xC0,0xC0,0xFC,0xFC,0xFC,0xC0,0x00,0x00,  
    0x00,0x80,0xC0,0xC0,0xC0,0xC0,0x80,0x80,0xFC,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,  
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,                                     
                                                                                      
    0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x07,0x0E,0x18,0x30,0x61,0x63,0xC6,0x8C,0x88,  
    0x98,0x98,0x11,0x11,0x11,0x11,0x11,0x11,0x90,0x98,0x88,0x8C,0xC6,0x63,0x61,0x30,  
    0x18,0x0C,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x03,0x07,0x1C,0x70,0xE0,0x81,0x07,  
    0x0E,0x38,0xE0,0xC1,0x07,0x0E,0x38,0x70,0xC0,0x00,0x00,0x00,0x00,0x00,0x0F,0x3F,  
    0x7F,0xF0,0xC0,0xC0,0x80,0x80,0x80,0x80,0xC0,0xC0,0xE0,0x60,0x00,0x00,0x00,0x3F,  
    0xFF,0xFF,0xC1,0x80,0x80,0x80,0xC1,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x03,0xCF,0x8F,  
    0x9E,0x9C,0xFC,0xF8,0x20,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xFF,0xFF,0xFF,  
    0x00,0x00,0x3E,0x7F,0xFF,0xCD,0x8C,0x8C,0x8C,0x8C,0xCF,0xCF,0x0E,0x08,0x00,0x03,  
    0xC7,0x8F,0x8E,0x9C,0xFC,0xF9,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
    0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x3E,0x7F,0xFF,0xCD,0xCC,0x8C,0x8C,0x8C,  
    0xCF,0xCF,0x0F,0x0C,0x00,0x00,0x1C,0x7F,0xFF,0xE3,0xC1,0x80,0x80,0x80,0xC1,0xC1,  
    0x41,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x01,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,  
    0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x01,0xFF,0xFF,0xFF,0x00,0x00,0x08,0x3E,0x7F,0xFF,  
    0xC1,0x80,0x80,0x80,0xC1,0xFF,0x7F,0x3E,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x3E,  
    0x7F,0xFF,0xC1,0x80,0x80,0x80,0xC1,0xE3,0x7F,0x3F,0x08,0x00,0x0C,0x7F,0xFF,0xE3,  
    0xC1,0x80,0x80,0x80,0xC1,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x03,0x0F,0x3F,0xFC,0xF0,  
    0xF8,0x7E,0x1F,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x3F,  
    0x7F,0xF0,0xC0,0xC0,0x80,0x80,0x80,0x80,0xC0,0xC0,0xE0,0x60,0x00,0x00,0x08,0x3E,  
    0x7F,0xFF,0xC1,0x80,0x80,0x80,0xC1,0xFF,0x7F,0x3E,0x00,0x00,0x80,0xC0,0xC0,0x00,  
    0x00,0x00,0x00,0x00,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
    0x00,0xFF,0xFF,0xFF,0x80,0x80,0x80,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x1C,  
    0x7F,0xFF,0xE1,0xC0,0x80,0x80,0xC0,0xE1,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xC0,0xC0,  
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,                                     
                                                                                      
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,  
    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,  
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,  
    0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
    0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
    0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x01,  
    0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,  
    0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
    0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
    0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,  
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,  
    0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,  
    0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,  
    0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,  
    0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x0E,0x0E,  
    0x0D,0x09,0x09,0x08,0x0C,0x0F,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x0C,0x0F,0x0F,  
    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
    0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
    0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,  
    0x00,0x00,0x00,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
    0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,  
    0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,  
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,                                     
};

TRANS_TOTAL stBankTotal;
BOOL	fRePrintFlag = FALSE; 

static CTOS_FONT_ATTRIB stgFONT_ATTRIB;

void vdSetGolbFontAttrib(USHORT FontSize, USHORT X_Zoom, USHORT Y_Zoom, USHORT X_Space, USHORT Y_Space)
{
    memset(&stgFONT_ATTRIB, 0x00, sizeof(stgFONT_ATTRIB));
    
    stgFONT_ATTRIB.FontSize = FontSize;      // Font Size = 12x24
	stgFONT_ATTRIB.X_Zoom = X_Zoom;		    // The width magnifies X_Zoom diameters
	stgFONT_ATTRIB.Y_Zoom = Y_Zoom;		    // The height magnifies Y_Zoom diameters

    stgFONT_ATTRIB.X_Space = X_Space;      // The width of the space between the font with next font
    stgFONT_ATTRIB.Y_Space = Y_Space;      // The Height of the space between the font with next font      
    
}

short printCheckPaper(void)
{
	unsigned short inRet;
	unsigned char key;

//fix for issue
//Must have no logo / image above and Must go back to idle screen
//#00089
   //CTOS_LCDTClearDisplay();
	
	while(1)
	{
		inRet = CTOS_PrinterStatus();
		if (inRet==d_OK)
			return 0;
		else if(inRet==d_PRINTER_PAPER_OUT)
		{
			vduiClearBelow(3);
			vduiWarningSound();
			vduiDisplayStringCenter(3,"PRINTER OUT OF");
			vduiDisplayStringCenter(4,"PAPER, INSERT");
			vduiDisplayStringCenter(5,"PAPER AND PRESS");
			vduiDisplayStringCenter(6,"ANY TO PRINT.");
			vduiDisplayStringCenter(8,"[X] CANCEL PRINT");

			CTOS_KBDGet(&key);
			if(key==d_KBD_CANCEL)
				return -1;	
		}		
	}	
}


void cardMasking(char *szPan, int style)
{
    int num;
    int i;
	char szTemp[30+1];
	
    if (style == PRINT_CARD_MASKING_1)
    {
        num = strlen(szPan) - 10;
        if (num > 0)
        {
            for (i = 0; i < num; i++)
            {
                szPan[6+i] = '*';
            }
        }
    }
    else if (style == PRINT_CARD_MASKING_2)
    {
        num = strlen(szPan) - 12;
        if (num > 0)
        {
            for (i = 0; i < num; i++)
            {
                szPan[12+i] = '*';
            }
        }
    }
    else if (style == PRINT_CARD_MASKING_3)
    {
        memset(szTemp, 0x00, sizeof(szTemp));
        strcpy(szTemp,"****************");
        num = strlen(szPan) - 4;
        memcpy(&szTemp[num],&szPan[num],4);
		szTemp[strlen(szPan)]=0x00;
        strcpy(szPan,szTemp);
    }
}

void vdCTOS_FormatDate(char *pchDate)
 {
	char szLocal[6 + 1] = {0};
	char szMonthNames[36 + 1] = {0};
	short Month = 0;

	strcpy(szLocal, pchDate);
	Month = (szLocal[2] - '0') * 10 + (szLocal[3] - '0') - 1;
	strcpy(szMonthNames, "JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC");
	sprintf(pchDate, "%.3s.%.2s,20%.2s", &(szMonthNames[Month * 3]), &(szLocal[4]), szLocal);

	pchDate[13] = ((char) 0);
}

#if 0
USHORT printDateTime(void)
{
    char szStr[d_LINE_SIZE + 1];
    char szTemp[d_LINE_SIZE + 1];
    char szTemp1[d_LINE_SIZE + 1];
    USHORT result;
    BYTE baTemp[PAPER_X_SIZE * 64];
  	CTOS_RTC SetRTC;
	char szYear[3];
	char szTempDate[d_LINE_SIZE + 1];

    memset(szStr, ' ', d_LINE_SIZE);
    memset(szTemp, ' ', d_LINE_SIZE);
	
	CTOS_RTCGet(&SetRTC);
	sprintf(szYear ,"%02d",SetRTC.bYear);
	memcpy(srTransRec.szYear,szYear,2);

	CTOS_PrinterPutString(szYear);
	
	vdDebug_LogPrintf("year[%s],date[%02x][%02x]",srTransRec.szYear,srTransRec.szDate[0],srTransRec.szDate[1]);
    	wub_hex_2_str(srTransRec.szDate, szTemp,DATE_BCD_SIZE);
    	wub_hex_2_str(srTransRec.szTime, szTemp1,TIME_BCD_SIZE);
	vdDebug_LogPrintf("date[%s],time[%s]atol(szTemp)=[%d](atol(szTemp1)=[%d]",szTemp,szTemp1,atol(szTemp),atol(szTemp1) );

	if(atol(szTemp) == 0)
	{
		sprintf(szTemp ,"%02d%02d",SetRTC.bDay,SetRTC.bMonth);	
	}
	if(atol(szTemp1) == 0)
	{
		sprintf(szTemp1 ,"%02d%02d%02d",SetRTC.bHour,SetRTC.bMinute,SetRTC.bSecond);	

	}
	vdDebug_LogPrintf("date[%s],time[%s]",szTemp,szTemp1);

	CTOS_PrinterPutString(szTemp);
	CTOS_PrinterPutString(szTemp1);
	
    #if 0
    sprintf(szStr,"DATE/TIME : %02lu/%02lu/%02lu	  %02lu:%02lu:%02lu",atol(szTemp)%100,atol(szTemp)/100,atol(srTransRec.szYear),atol(szTemp1)/10000,atol(szTemp1)%10000/100, atol(szTemp1)%100);
    memset (baTemp, 0x00, sizeof(baTemp));	  
    CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
    result = CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
    #else
    memset(szTempDate, 0x00, sizeof(szTempDate));
    sprintf(szTempDate, "%02lu%02lu%02lu", atol(srTransRec.szYear), atol(szTemp)/100, atol(szTemp)%100);
    CTOS_PrinterPutString(szTempDate);
	
    vdCTOS_FormatDate(szTempDate);
    sprintf(szStr,"DATE/TIME: %s %02lu:%02lu:%02lu",szTempDate,atol(szTemp1)/10000,atol(szTemp1)%10000/100, atol(szTemp1)%100);
    inPrint(szStr);
    #endif  
    
    return(result);
     
}
#else
USHORT printDateTime(void)
{
	BYTE   EMVtagVal[64];
	USHORT EMVtagLen; 
	int result;
	char szStr[35 + 1];
	CTOS_RTC SetRTC;
	char szYear[3];
	char szTempDate[d_LINE_SIZE + 1];
	char szTemp[d_LINE_SIZE + 1];
	char szTemp2[d_LINE_SIZE + 1];
	char szTemp3[d_LINE_SIZE + 1];
	char szTemp4[d_LINE_SIZE + 1];
	char szTermSerialNum[15+1]; // print terminal serial number on all txn receipt - mfl
	BYTE baTemp[PAPER_X_SIZE * 64];

	CTOS_RTCGet(&SetRTC);
	sprintf(szYear ,"%02d",SetRTC.bYear);
	memcpy(srTransRec.szYear,szYear,2);

	memset(szTemp, 0x00, sizeof(szTemp));
	memset(szTemp2, 0x00, sizeof(szTemp2));
	memset(szTemp3, 0x00, sizeof(szTemp3));
	memset(szTemp4, 0x00, sizeof(szTemp4));
	wub_hex_2_str(srTransRec.szDate, szTemp,DATE_BCD_SIZE);
	wub_hex_2_str(srTransRec.szTime, szTemp2,TIME_BCD_SIZE);
	memset(szTempDate, 0x00, sizeof(szTempDate));
	sprintf(szTempDate, "%02lu%02lu%02lu", atol(srTransRec.szYear), atol(szTemp)/100, atol(szTemp)%100);
	vdCTOS_FormatDate(szTempDate);
	sprintf(szTemp3, "DATE: %s", szTempDate);
	sprintf(szTemp4, "TIME: %02lu:%02lu:%02lu", atol(szTemp2)/10000,atol(szTemp2)%10000/100, atol(szTemp2)%100);
	inPrintLeftRight(szTemp3, szTemp4, 46);

	return(ST_SUCCESS);
	
}
#endif



#if 0
USHORT printTIDMID(void)
{
    char szStr[d_LINE_SIZE + 1];
    USHORT result;
    BYTE baTemp[PAPER_X_SIZE * 64];
	
	memset(szStr, ' ', d_LINE_SIZE);
    sprintf(szStr, "TID: %s", srTransRec.szTID);
    memset (baTemp, 0x00, sizeof(baTemp));		 
    CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
    result = CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 

    memset(szStr, ' ', d_LINE_SIZE);
    sprintf(szStr, "MID: %s", srTransRec.szMID);
    memset (baTemp, 0x00, sizeof(baTemp));		 
    CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
    result = CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
    
    return (result);


}

USHORT printBatchInvoiceNO(void)
{
    char szStr[d_LINE_SIZE + 1];
    char szTemp1[d_LINE_SIZE + 1];
    char szTemp2[d_LINE_SIZE + 1];
    USHORT result;
    BYTE baTemp[PAPER_X_SIZE * 64];
        
    memset(szStr, ' ', d_LINE_SIZE);
    memset(szTemp1, ' ', d_LINE_SIZE);
    memset(szTemp2, ' ', d_LINE_SIZE);
	
	wub_hex_2_str(srTransRec.szBatchNo,szTemp1,3);
    wub_hex_2_str(srTransRec.szInvoiceNo, szTemp2, INVOICE_BCD_SIZE);
    vdMyEZLib_LogPrintf("invoice no: %s",szTemp2);
	memset(szStr, 0x00, d_LINE_SIZE);
    sprintf(szStr, "BATCH NUM: %s", szTemp1);
	result=inPrint(szStr);

	memset(szStr, 0x00, d_LINE_SIZE);
    sprintf(szStr, "TRACE NO.: %s", szTemp2);
	result=inPrint(szStr);
	
    return(result);
}

#else
USHORT printTIDMID(void)
{
    char szStr[d_LINE_SIZE + 1];
    char szStr1[d_LINE_SIZE + 1];
	
    USHORT result;
    BYTE baTemp[PAPER_X_SIZE * 64];
	
	memset(szStr, ' ', d_LINE_SIZE);
	sprintf(szStr, "TID: %s", srTransRec.szTID);

	memset(szStr1, ' ', d_LINE_SIZE);
	sprintf(szStr1, "MID: %s", srTransRec.szMID);

	inPrintLeftRight(szStr, szStr1, 46);
    
    return d_OK;

}

USHORT printBatchInvoiceNO(void)
{
    char szStr[d_LINE_SIZE + 1];
    char szStr1[d_LINE_SIZE + 1];
	
    char szTemp1[d_LINE_SIZE + 1];
    char szTemp2[d_LINE_SIZE + 1];
    USHORT result;
    BYTE baTemp[PAPER_X_SIZE * 64];
        
    memset(szStr, ' ', d_LINE_SIZE);
    memset(szTemp1, ' ', d_LINE_SIZE);
    memset(szTemp2, ' ', d_LINE_SIZE);
	
	wub_hex_2_str(srTransRec.szBatchNo,szTemp1,3);
	wub_hex_2_str(srTransRec.szInvoiceNo, szTemp2, INVOICE_BCD_SIZE);
	vdMyEZLib_LogPrintf("invoice no: %s",szTemp2);
	memset(szStr, 0x00, d_LINE_SIZE);
	sprintf(szStr, "BATCH NUM: %s", szTemp1);
	//result=inPrint(szStr);

	memset(szStr1, 0x00, d_LINE_SIZE);
	sprintf(szStr1, "TRACE NO.: %s", szTemp2);
	//result=inPrint(szStr);

	inPrintLeftRight(szStr, szStr1, 46);
	
    return d_OK;
}
#endif

USHORT printBatchNO(void)
{
    char szStr[d_LINE_SIZE + 1];
    char szTemp[d_LINE_SIZE + 1];
    BYTE baTemp[PAPER_X_SIZE * 64];
    USHORT result;
    char szTermSerialNum[15+1]; // print terminal serial number on all txn receipt - mfl
    
    memset(szStr, ' ', d_LINE_SIZE);
    memset(szTemp, ' ', d_LINE_SIZE);
	
	wub_hex_2_str(srTransRec.szBatchNo,szTemp,3);
    sprintf(szStr, "BATCH NO: %s", szTemp);
    memset (baTemp, 0x00, sizeof(baTemp));		

    CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
    result = CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
	//Terminal serial number - mfl		
	memset(szTemp, ' ', d_LINE_SIZE);
    	memset (baTemp, 0x00, sizeof(baTemp));			
	memset(szTermSerialNum, 0x00, sizeof(szTermSerialNum)); 
	CTOS_GetFactorySN(szTermSerialNum);		 
	szTermSerialNum[15]=0; // eliminate check digit
	
	//sprintf(szStr, "TERMINAL SERIAL NUM: %s", szTermSerialNum);
	sprintf(szStr, "TSN: %s", szTermSerialNum);
	 
         CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
         result = CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
	//
    return(result);
}

USHORT printHostLabel(void)
{
    char szStr[d_LINE_SIZE + 1];
    BYTE baTemp[PAPER_X_SIZE * 64];
    USHORT result;

    memset(szStr, 0x00, sizeof(szStr));
    sprintf(szStr, "HOST: %s", srTransRec.szHostLabel);
    memset (baTemp, 0x00, sizeof(baTemp));		

    CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
    result = CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
    return(result);
}


void vdPrintCenter(unsigned char *strIn)
{
	unsigned char tucPrint [24*4+1];
	short i,spacestring;
    USHORT usCharPerLine = 32;
    BYTE baTemp[PAPER_X_SIZE * 64];

    if(d_FONT_24x24 == stgFONT_ATTRIB.FontSize && NORMAL_SIZE == stgFONT_ATTRIB.X_Zoom)
        usCharPerLine = 32;
    else if(d_FONT_24x24 == stgFONT_ATTRIB.FontSize && DOUBLE_SIZE == stgFONT_ATTRIB.X_Zoom)
        usCharPerLine = 16;
    else if(d_FONT_16x16 == stgFONT_ATTRIB.FontSize && NORMAL_SIZE == stgFONT_ATTRIB.X_Zoom)
        usCharPerLine = 48;
    else if(d_FONT_16x16 == stgFONT_ATTRIB.FontSize && DOUBLE_SIZE == stgFONT_ATTRIB.X_Zoom)
        usCharPerLine = 24;
    else
        usCharPerLine = 32;
        
    i = strlen(strIn);
	spacestring=(usCharPerLine-i)/2;
				
	memset(tucPrint,0x20,55);
	memcpy(tucPrint+spacestring,strIn,usCharPerLine);	
	
	tucPrint[i+spacestring]=0;
    memset (baTemp, 0x00, sizeof(baTemp));
      
    CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, tucPrint, &stgFONT_ATTRIB);
    CTOS_PrinterBufferOutput((BYTE *)baTemp, 3); 
}

void vdPrintTitleCenter(unsigned char *strIn)
{
	unsigned char tucPrint [24*4+1];
	short i,spacestring;
    USHORT usCharPerLine = 24;
    BYTE baTemp[PAPER_X_SIZE * 64];

    vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
    //vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
    
    i = strlen(strIn);
	spacestring=(usCharPerLine-i)/2;
				
	memset(tucPrint,0x20,30);
	
	memcpy(tucPrint+spacestring,strIn,usCharPerLine);	
	
	tucPrint[i+spacestring]=0;
        
    memset (baTemp, 0x00, sizeof(baTemp));	
    CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, tucPrint, &stgFONT_ATTRIB);
    CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 

    vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, NORMAL_SIZE, 0, 0);
    
}

USHORT printDividingLine(int style)
{
    if (style == DIVIDING_LINE_DOUBLE)
        return(CTOS_PrinterPutString("==========================================="));
    else
        return(CTOS_PrinterPutString("-------------------------------------------"));
}

void vdCTOSS_GetEMVTagsDescription(USHORT usTag, char *szValue)
{
    switch(usTag)
    {
        case TAG_50:
            strcpy(szValue, "Appl Label");
            break;

        case TAG_57:
            strcpy(szValue, "Track2 Data");
            break;

        case TAG_5F2A_TRANS_CURRENCY_CODE:
            strcpy(szValue, "Txn CurrCode");
            break;

        case TAG_5F34_PAN_IDENTFY_NO:
            strcpy(szValue, "PAN Seq Num");
            break;

        case TAG_82_AIP:
            strcpy(szValue, "AIP");
            break;

        case TAG_8A_AUTH_CODE:
            strcpy(szValue, "Auth Code");
            break;

        case TAG_8F:
            strcpy(szValue, "CAPK Index");
            break;

        case TAG_91_ARPC:
            strcpy(szValue, "ARPC");
            break;

        case TAG_95:
            strcpy(szValue, "TVR");
            break;

        case TAG_9A_TRANS_DATE:
            strcpy(szValue, "Txn Date");
            break;

        case TAG_9B:
            strcpy(szValue, "TSI");
            break;

        case TAG_9C_TRANS_TYPE:
            strcpy(szValue, "Txn Type");
            break;

        case TAG_9F02_AUTH_AMOUNT:
            strcpy(szValue, "Txn Amt");
            break;

        case TAG_9F03_OTHER_AMOUNT:
            strcpy(szValue, "Other Amt");
            break;

        case TAG_9F10_IAP:
            strcpy(szValue, "IAP");
            break;

        case TAG_9F12:
            strcpy(szValue, "Appl Pref Name");
            break;

        case TAG_9F1A_TERM_COUNTRY_CODE:
            strcpy(szValue, "Term CurrCode");
            break;

        case TAG_9F1B_TERM_FLOOR_LIMIT:
            strcpy(szValue, "FloorLimit");
            break;

        case TAG_9F26_EMV_AC:
            strcpy(szValue, "AC");
            break;

        case TAG_9F27:
            strcpy(szValue, "CID");
            break;

        case TAG_9F33_TERM_CAB:
            strcpy(szValue, "Term Cab");
            break;

        case TAG_9F34_CVM:
            strcpy(szValue, "CVM");
            break;

        case TAG_9F36_ATC:
            strcpy(szValue, "ATC");
            break;

        case TAG_9F37_UNPREDICT_NUM:
            strcpy(szValue, "Unpredict Num");
            break;

        case TAG_9F5B:
            strcpy(szValue, "Script Result");
            break;

        case TAG_71:
            strcpy(szValue, "Issuer Script1");
            break;

        case TAG_72:
            strcpy(szValue, "Issuer Script2");
            break;

        default :
            szValue[0] = 0x00;
            break;
    }
}

void vdPrintEMVTags(void)
{
    BYTE   EMVtagVal[64];
    USHORT EMVtagLen;
    USHORT usPrintTag;
    USHORT usPrintTagLen;
    USHORT usOffset;
    char szStr[d_LINE_SIZE + 1];
    char szTagDesp[50];
    char szEMVTagList[512];
    char szEMVTagListHex[256];
    BYTE szOutEMVData[2048];
    USHORT inTagLen = 0;
    int shHostIndex, inRet=0;
	
    shHostIndex = inCTOS_SelectHostSetting();
    if (shHostIndex == -1)
        return;

	CTOS_LCDTClearDisplay();

    if (inMultiAP_CheckMainAPStatus() == d_OK)
    {
        inRet = inCTOS_MultiAPSaveData(d_IPC_CMD_PRINT_EMV_TAGS);
        if(d_OK != inRet)
              return ;
    }
	else
	{
        if (inMultiAP_CheckSubAPStatus() == d_OK)
        {
            inRet = inCTOS_MultiAPGetData();
            if(d_OK != inRet)
                return ;
            
            inRet = inCTOS_MultiAPReloadHost();
            if(d_OK != inRet)
                return ;
        }
    }    
	
    CTOS_PrinterSetHeatLevel(4);
    if( printCheckPaper()==-1)
    	return ;

    vdSetPrintThreadStatus(1); //Not displaying "Printing" while receipt is printing. White screen / Host Selection Menu appears while printing - ##00129
	
    CTOS_LanguagePrinterFontSize(d_FONT_16x16, 0, TRUE);	
	
	vdCTOSS_PrinterBMPPic(0, 0, "logo.bmp");
	
    vdPrintTitleCenter("EMV TAGS DATA");

    memset(szOutEMVData,0x00,sizeof(szOutEMVData));

    usCTOSS_EMV_MultiDataGet(PRINT_EMV_TAGS_LIST, &inTagLen, szOutEMVData);
    DebugAddHEX("PRINT_EMV_TAGS_LIST",szOutEMVData,inTagLen);

    memset(szEMVTagList,0x00,sizeof(szEMVTagList));
    memset(szEMVTagListHex,0x00,sizeof(szEMVTagListHex));
    strcpy(szEMVTagList, PRINT_EMV_TAGS_LIST);
    wub_str_2_hex(szEMVTagList, szEMVTagListHex, strlen(szEMVTagList));

    usOffset = 0;
    while(szEMVTagListHex[usOffset] != 0x00)
    {
        CTOS_PrinterFline(d_LINE_DOT * 1);
        
        memset(szStr, 0x00, sizeof(szStr));
        if ((szEMVTagListHex[usOffset] & 0x1F) == 0x1F)	// If the least 5 bits of the first byte are set, it is a two byte Tag
    	{
    		usPrintTag = szEMVTagListHex[usOffset];
    		usPrintTag = ((usPrintTag << 8) | szEMVTagListHex[usOffset+1]);
    		usPrintTagLen = 2;		
    	}
    	else
    	{
    		usPrintTag = szEMVTagListHex[usOffset];
            usPrintTag = usPrintTag & 0x00FF;
            usPrintTagLen = 1;
    	}
        memcpy(szStr, &szEMVTagList[usOffset*2], usPrintTagLen*2);
        usOffset += usPrintTagLen;

        memset(szTagDesp,0x00,sizeof(szTagDesp));
        vdCTOSS_GetEMVTagsDescription(usPrintTag, szTagDesp);
        vdDebug_LogPrintf("szStr[%s] usPrintTag[%X] szTagDesp[%s]", szStr, usPrintTag, szTagDesp);  
        vdMyEZLib_Printf("%s (%s)", szStr,szTagDesp);
        memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
        EMVtagLen = 0;
        usCTOSS_FindTagFromDataPackage(usPrintTag, EMVtagVal, &EMVtagLen, szOutEMVData, inTagLen);
        memset(szStr, ' ', d_LINE_SIZE);
        if(EMVtagLen == 0)
            memcpy(szStr,"No DATA" , 7);
        else    
            wub_hex_2_str(EMVtagVal, szStr, EMVtagLen);
        vdMyEZLib_Printf("Len:%d val:%s", EMVtagLen, szStr);
    }
        
    CTOS_PrinterFline(d_LINE_DOT * 1);
    vdPrintTitleCenter("*** END OF REPORT ***");
    CTOS_PrinterFline(d_LINE_DOT * 10); 
  
}

void vdPrintTerminalConfig(void)
{
    int inResult;
    int shHostIndex = 1;
    int inNum = 0;
    int inNumOfHost = 0;
    int inNumOfMerchant = 0;
    int inLoop =0 ;
    BYTE szStr[50];
    BYTE szBuf[50];
    BYTE baTemp[PAPER_X_SIZE * 64];

    inCTOS_SelectFont(d_FONT_FNT_MODE,d_FONT_24x24,0," ");
    vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);
    
    CTOS_PrinterSetHeatLevel(4);  

	ushCTOS_PrintHeader(0);

    CTOS_PrinterFline(d_LINE_DOT * 1);
            
    memset(szStr, 0x00, sizeof(szStr));
    memset(szBuf, 0x00, sizeof(szBuf));
    wub_hex_2_str(strTCT.szInvoiceNo, szBuf, 3);
    sprintf(szStr, "INVOICE NO: %s", szBuf);                        
    memset (baTemp, 0x00, sizeof(baTemp));
    CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
    CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

    memset(szStr, 0x00, sizeof(szStr));
    sprintf(szStr, "PABX: %s", strTCT.szPabx);                        
    memset (baTemp, 0x00, sizeof(baTemp));
    CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
    CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

    memset (baTemp, 0x00, sizeof(baTemp));
    CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
    CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
    
    //check host num
    inNumOfHost = inHDTNumRecord();
    
    vdDebug_LogPrintf("[inNumOfHost]-[%d]", inNumOfHost);
    for(inNum =1 ;inNum <= inNumOfHost; inNum++)
    {
        if(inHDTRead(inNum) == d_OK)
        {                
            inCPTRead(inNum);

            CTOS_PrinterFline(d_LINE_DOT * 1);
            
            memset(szStr, 0x00, sizeof(szStr));
            sprintf(szStr, "HOST: %s", strHDT.szHostLabel);                        
            memset (baTemp, 0x00, sizeof(baTemp));
            CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 

            memset(szStr, 0x00, sizeof(szStr));
            memset(szBuf, 0x00, sizeof(szBuf));
            wub_hex_2_str(strHDT.szTPDU, szBuf, 5);
            sprintf(szStr, "TPDU: %s", szBuf);                        
            memset (baTemp, 0x00, sizeof(baTemp));
            CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 

            memset(szStr, 0x00, sizeof(szStr));
            if(strCPT.inCommunicationMode == ETHERNET_MODE)
            {   
                sprintf(szStr, "COMM TYPE: %s", "ETHERNET");           
            }
            else if(strCPT.inCommunicationMode == DIAL_UP_MODE)
            {
                sprintf(szStr, "COMM TYPE: %s", "DIAL_UP");         
            }       
            else if(strCPT.inCommunicationMode == GPRS_MODE)
            {
                sprintf(szStr, "COMM TYPE: %s", "GPRS");                 
            }
            memset (baTemp, 0x00, sizeof(baTemp));
            CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

            memset(szStr, 0x00, sizeof(szStr));
            sprintf(szStr, "PRI NUM : %s", strCPT.szPriTxnPhoneNumber);                        
            memset (baTemp, 0x00, sizeof(baTemp));
            CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

            memset(szStr, 0x00, sizeof(szStr));
            sprintf(szStr, "SEC NUM : %s", strCPT.szSecTxnPhoneNumber);                        
            memset (baTemp, 0x00, sizeof(baTemp));
            CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 

            memset(szStr, 0x00, sizeof(szStr));
            sprintf(szStr, "PRI IP  : %s", strCPT.szPriTxnHostIP);                        
            memset (baTemp, 0x00, sizeof(baTemp));
            CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

            memset(szStr, 0x00, sizeof(szStr));
            sprintf(szStr, "PRI PORT: %d", strCPT.inPriTxnHostPortNum);                        
            memset (baTemp, 0x00, sizeof(baTemp));
            CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

            memset(szStr, 0x00, sizeof(szStr));
            sprintf(szStr, "SEC IP  : %s", strCPT.szSecTxnHostIP);                        
            memset (baTemp, 0x00, sizeof(baTemp));
            CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

            memset(szStr, 0x00, sizeof(szStr));
            sprintf(szStr, "SEC PORT: %d", strCPT.inSecTxnHostPortNum);                        
            memset (baTemp, 0x00, sizeof(baTemp));
            CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

            inMMTReadNumofRecords(strHDT.inHostIndex,&inNumOfMerchant);
        
            vdDebug_LogPrintf("[inNumOfMerchant]-[%d]strHDT.inHostIndex[%d]", inNumOfMerchant,strHDT.inHostIndex);
            for(inLoop=1; inLoop <= inNumOfMerchant;inLoop++)
            {
                if((inResult = inMMTReadRecord(strHDT.inHostIndex,strMMT[inLoop-1].MITid)) !=d_OK)
                {
                    vdDebug_LogPrintf("[read MMT fail]-Mitid[%d]strHDT.inHostIndex[%d]inResult[%d]", strMMT[inLoop-1].MITid,strHDT.inHostIndex,inResult);
                    continue;
                    //break;
                }
                else 
                {
                    if(strMMT[0].fMMTEnable)
                    {                        
                        memset(szStr, 0x00, sizeof(szStr));
                        sprintf(szStr, "MERCHANT:%s", strMMT[0].szMerchantName);                        
                        memset (baTemp, 0x00, sizeof(baTemp));
                        CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
                        CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

                        memset(szStr, 0x00, sizeof(szStr));
                        sprintf(szStr, "TID : %s", strMMT[0].szTID);                        
                        memset (baTemp, 0x00, sizeof(baTemp));
                        CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
                        CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

                        memset(szStr, 0x00, sizeof(szStr));
                        sprintf(szStr, "MID : %s", strMMT[0].szMID);                        
                        memset (baTemp, 0x00, sizeof(baTemp));
                        CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
                        CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

                        memset(szStr, 0x00, sizeof(szStr));
                        memset(szBuf, 0x00, sizeof(szBuf));
                        wub_hex_2_str(strMMT[0].szBatchNo, szBuf, 3);
                        sprintf(szStr, "BATCH NO: %s", szBuf);                        
                        memset (baTemp, 0x00, sizeof(baTemp));
                        CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
                        CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

                    }                    

                }
            }
        }
        else
            continue;

    }

    CTOS_PrinterFline(d_LINE_DOT * 5);
    
    return ;
}

void printCardHolderName(void)
{
    USHORT shLen;
    char szStr[d_LINE_SIZE + 1];
    
    shLen = strlen(srTransRec.szCardholderName);

    if(shLen > 0)
    {
        memset(szStr, 0x00, d_LINE_SIZE);
        strcpy(szStr, srTransRec.szCardholderName);
		szStr[31] = 0x00; //#00192 - Incorrect number of characters of Cardholder's Name in original and duplicate receipt

	// old code
        //while(0x20 == szStr[--shLen] && shLen >= 0)
           // szStr[shLen] = 0x00;

    	//vdPrintCenter(szStr);	
    	inPrint(szStr);
    }
}



void printCardHolderNameEntryMode(void)
{
    USHORT shLen;
    char szStr[d_LINE_SIZE + 1];
    char szTemp1[d_LINE_SIZE + 1];
    
    shLen = strlen(srTransRec.szCardholderName);

    if(shLen > 0)
    {
        memset(szStr, 0x00, d_LINE_SIZE);
        strcpy(szStr, srTransRec.szCardholderName);
		szStr[31] = 0x00; //#00192 - Incorrect number of characters of Cardholder's Name in original and duplicate receipt

	// old code
        //while(0x20 == szStr[--shLen] && shLen >= 0)
           // szStr[shLen] = 0x00;

    	//vdPrintCenter(szStr);	
    	//inPrint(szStr);
    }

		memset(szTemp1, 0, sizeof(szTemp1));

		if(srTransRec.byEntryMode==CARD_ENTRY_ICC)
			memcpy(szTemp1,"ICC",4);
		else if(srTransRec.byEntryMode==CARD_ENTRY_MANUAL)
			memcpy(szTemp1,"Manual",6);
		else if(srTransRec.byEntryMode==CARD_ENTRY_MSR)
			memcpy(szTemp1,"MSR",3);
		else if(srTransRec.byEntryMode==CARD_ENTRY_FALLBACK)
			memcpy(szTemp1,"Fallback",8);
		else if(srTransRec.byEntryMode==CARD_ENTRY_WAVE)
		{
			if ('4' ==srTransRec.szPAN[0])
				memcpy(szTemp1,"CONTACTLESS",7);
			if ('5' ==srTransRec.szPAN[0])
				memcpy(szTemp1,"CONTACTLESS",7);
		}

	//#00059 - Terminal prints card no. Twice when process as manual entry
	if(srTransRec.byEntryMode==CARD_ENTRY_MANUAL || strCDT.inType == DEBIT_CARD)
		inPrint(szTemp1);
	else
		inPrintLeftRight(szStr, szTemp1, 46);
		
	
}

void vdPrintFormattedAmount(unsigned char *prtDisplay, unsigned char *prtAmount, int inWidth)
{
    char szAmtBuf[24+1] = { 0 };
	char szStr[24+1] = { 0 };

	memset(szStr, 0, sizeof(szStr));
	memset(szAmtBuf, 0, sizeof(szAmtBuf));
	if(srTransRec.byVoided == TRUE)
	{
		szAmtBuf[0]='-';
	    vdCTOS_FormatAmount("NNN,NNN,NNn.nn", prtAmount, &szAmtBuf[1]);
	}
	else
	    vdCTOS_FormatAmount("NNN,NNN,NNn.nn", prtAmount, szAmtBuf);
	
	sprintf(szStr, "%s%s", prtDisplay, strCST.szCurSymbol);
	inPrintLeftRight(szStr, szAmtBuf, inWidth);
}

USHORT ushCTOS_PrintDemo(void)
{
    BYTE strIn[40];
    unsigned char tucPrint [24*4+1];
    short i,spacestring;
    USHORT usCharPerLine = 24;
    BYTE baTemp[PAPER_X_SIZE * 64];

    vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
    //vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);

    memset(strIn, 0x00, sizeof(strIn));
    strcpy(strIn, "DEMO");
    i = strlen(strIn);
    spacestring=(usCharPerLine-i)/2;
                
    memset(tucPrint,0x20,30);
    
    memcpy(tucPrint+spacestring,strIn,usCharPerLine);   
    
    tucPrint[i+spacestring]=0;

    //CTOS_PrinterFline(d_LINE_DOT * 1);
        
    memset (baTemp, 0x00, sizeof(baTemp));  
    CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, tucPrint, &stgFONT_ATTRIB);
    CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 

    //CTOS_PrinterFline(d_LINE_DOT * 1);

	vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, NORMAL_SIZE, 0, 0);

    return d_OK;
    
}



USHORT ushCTOS_PrintHeader(int page)
{	

    vdDebug_LogPrintf("ushCTOS_PrintHeader-1");
    
	//print Logo	
	if(strlen(strHDT.szHeaderLogoName))
		vdCTOSS_PrinterBMPPic(0, 0, strHDT.szHeaderLogoName);
	else
		vdCTOSS_PrinterBMPPic(0, 0, "logo.bmp");

    vdDebug_LogPrintf("ushCTOS_PrintHeader-2");
#if 0
{
	char szTemp[50+1];
	memset(szTemp,0x00,sizeof(szTemp));
	sprintf(szTemp, "ushCTOS_PrintHeader:[%d]:[%d]", srTransRec.HDTid, srTransRec.MITid);
    	CTOS_PrinterPutString(szTemp);
	
}
#endif    

	if(fRePrintFlag == TRUE)
    {   
        vdDebug_LogPrintf("srTransRec.HDTid[%d] srTransRec.MITid[%d]",srTransRec.HDTid, srTransRec.MITid);
		if ( inMMTReadRecord(srTransRec.HDTid,srTransRec.MITid) != d_OK)
        {
            vdSetErrorMessage("LOAD MMT ERR");
            return(d_NO);
        }
        vdDebug_LogPrintf("srTransRec.HDTid[%d] srTransRec.MITid[%d] strMMT[0].szRctHdr1[%s]",srTransRec.HDTid, srTransRec.MITid, strMMT[0].szRctHdr1);
    }

    vdDebug_LogPrintf("ushCTOS_PrintHeader-3");

	vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
	//merhcant name and address
	if(strlen(strMMT[0].szRctHdr1) > 0)
		vdPrintCenter(strMMT[0].szRctHdr1);
	if(strlen(strMMT[0].szRctHdr2) > 0)
		vdPrintCenter(strMMT[0].szRctHdr2);
	if(strlen(strMMT[0].szRctHdr3) > 0)
    	vdPrintCenter(strMMT[0].szRctHdr3);
	if(strlen(strMMT[0].szRctHdr4) > 0)
    	vdPrintCenter(strMMT[0].szRctHdr4);
	if(strlen(strMMT[0].szRctHdr5) > 0)
    	vdPrintCenter(strMMT[0].szRctHdr5);

    //CTOS_PrinterFline(d_LINE_DOT * 1);
	
    if(VS_TRUE == strTCT.fDemo)
    {
        ushCTOS_PrintDemo();
    }

    if(fRePrintFlag == TRUE)
    {
        vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
        vdPrintCenter("DUPLICATE");
        vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, NORMAL_SIZE, 0, 0);
	CTOS_PrinterFline(d_LINE_DOT * 1);		
    }
    

    vdDebug_LogPrintf("ushCTOS_PrintHeader-end");    
	return d_OK;
	
}

USHORT ushCTOS_PrintInstallmentDetails(void)
{	
	char szTemp[d_LINE_SIZE+1];
	char szStr[d_LINE_SIZE+1];
	char szTempAmount[12+1];
	char szTempAmountHex[6+1];
    	TRANS_DATA_TABLE* srTransPara;

    	//CTOS_PrinterPutString("ushCTOS_PrintInstallmentDetails");	
	//vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
    	vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
	
	memset(szTemp, 0x00, d_LINE_SIZE);
	wub_hex_2_str(srTransRec.szTotalAmount, szTemp, AMT_BCD_SIZE);
	vdPrintFormattedAmount("TOTAL               :", szTemp, 46); // #00207 - Amount on Installment receipt should be left justify

	vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);

	inPrintLeftRight("PROMO               :", srTransRec.szPromoLabel, 46);

	inPrintLeftRight("TERMS               :", srTransRec.szTerms1, 46);//srTransRec.szTerms, 46);

	memset(szTemp, 0x00, d_LINE_SIZE);
	sprintf(szTemp, "%012ld", atol(srTransRec.szTotalInstAmnt));
	vdPrintFormattedAmount("GROSS AMT           :", szTemp, 46);

	// original script
	memset(szStr, 0x00, d_LINE_SIZE);
	memset(szTemp, 0x00, d_LINE_SIZE);
	//sprintf(szTemp, "%d", (int)srTransRec.szFactorRate);
	// #00033 Incorrect percentage data printed on receipt
	vdCTOSvdTrimLeadZeroes(srTransRec.szFactorRate);

	inPrintLeftRight("RATE                :", srTransRec.szFactorRate, 46);
	
	//inPrintLeftRight("RATE                :", srTransRec.szFactorRate, 46);

	memset(szTemp, 0x00, d_LINE_SIZE);
	sprintf(szTemp, "%012ld", atol(srTransRec.szMoAmort));
	vdPrintFormattedAmount("MONTHLY AMORTIZATION:", szTemp, 46);	
}

USHORT ushCTOS_PrintBody(int page)
{	
    char szStr[d_LINE_SIZE + 1];
    char szStr2[d_LINE_SIZE + 1];	
    char szTemp[d_LINE_SIZE + 1];
    char szTemp1[d_LINE_SIZE + 1];
    char szTemp3[d_LINE_SIZE + 1];
    char szTemp4[d_LINE_SIZE + 1];
    char szTemp5[d_LINE_SIZE + 1];
    char szFormatPAN[strlen(srTransRec.szPAN) + 7];//to account for space as in PAN format and to include additional PAN no. 7 has been added -Meena 08/01/2012
    int inFmtPANSize;
    BYTE baTemp[PAPER_X_SIZE * 64];
    USHORT result;
    int num,i,inResult;
    unsigned char tucPrint [24*4+1];	
    BYTE   EMVtagVal[64];
    USHORT EMVtagLen; 
    short spacestring;
    BYTE   key;
    char szTermSerialNum[15+1]; // print terminal serial number on all txn receipt - mfl


    //CTOS_PrinterPutString("ushCTOS_PrintBody");
   // 	CTOS_PrinterPutString(srTransRec.szTerms);
	
    //CTOS_PrinterPutString(srTransRec.szRRN); //srTransRec.szAuthCode
    //CTOS_PrinterPutString(srTransRec.szAuthCode);

#if 0
{
	char szTerms[20+1];
	memset(szTerms,0x00,sizeof(szTerms));
	sprintf(szTerms, "ushCTOS_PrintBody::%d:%d", srTransRec.byTransType, (int)srTransRec.fCash2Go);
	CTOS_PrinterPutString(szTerms);
	
}
#endif	

// fix for Wrong implementation of USD Currency
//USD currency prompts upon voiding & settlement
//Terminal prints incorrect amount currency on duplicate receipt (PHP Profile only)
// #00166
        inTCTRead(1);	
	if(strTCT.fRegUSD == 1) 
		inCSTRead(2);
	else
		inCSTRead(1);


    vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
	if(d_FIRST_PAGE == page)
	{

   	//CTOS_PrinterPutString("1ST PAGE");
	
    	//memset(szTemp1, ' ', d_LINE_SIZE);
    	//sprintf(szTemp1,"%s",srTransRec.szHostLabel);
    	//vdPrintCenter(szTemp1);

		// - print adjustment 07132015
		szGetTransTitle(srTransRec.byTransType, szStr);     
		inPrint(szStr);   
		// - print adjustment 07132015
		
		printDateTime();

		printTIDMID(); 

		printBatchInvoiceNO();

		//szGetTransTitle(srTransRec.byTransType, szStr);     -- orig code
		//vdPrintTitleCenter(szStr);    

		//CTOS_PrinterFline(d_LINE_DOT * 1); // space after printing trans title. - print adjustment 07132015

		//vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0); - print adjustment 07132015
		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
		memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
		EMVtagLen = 0;

#if 0		
		memset(szStr, ' ', d_LINE_SIZE);
		vdMyEZLib_LogPrintf("CDT index: %d",srTransRec.CDTid);

		sprintf(szStr, "%s", srTransRec.szCardLable);
		vdMyEZLib_LogPrintf("Card label: %s",srTransRec.szCardLable);
		
		memset (baTemp, 0x00, sizeof(baTemp));
		CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 

		//cardMasking(srTransRec.szPAN, PRINT_CARD_MASKING_1);
		//strcpy(szTemp4, srTransRec.szPAN);
		//memset (baTemp, 0x00, sizeof(baTemp));
		//CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szTemp4, &stgFONT_ATTRIB);
		//CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);		

        memset (baTemp, 0x00, sizeof(baTemp));
		vdCTOS_FormatPAN(strIIT.szMaskCustomerCopy, srTransRec.szPAN, baTemp);
        inPrint(baTemp);
#else // print CARD LABEL AND CARD NUMBER
		memset(szStr, ' ', d_LINE_SIZE);
		//sprintf(szStr, "%s", srTransRec.szCardLable);
		 if(strcmp(srTransRec.szCardLable, "BANCNET") == 0) //#00232 - When card process as DEBIT SALE terminal prints BANCNET instead of MCC DEBIT
		 		strcpy(szStr,"MCC DEBIT");    
		 else
				sprintf(szStr, "%s", srTransRec.szCardLable);

        	memset (baTemp, 0x00, sizeof(baTemp));
		vdCTOS_FormatPAN(strIIT.szMaskCustomerCopy, srTransRec.szPAN, baTemp);

		inPrintLeftRight(szStr, baTemp, 46);

#endif		
        vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);

#if 0
		printCardHolderName();
		
		//Exp date and Entry mode
		memset(szStr, ' ', d_LINE_SIZE);
		memset(szTemp, 0, sizeof(szTemp));
		memset(szTemp1, 0, sizeof(szTemp1));
		memset(szTemp4, 0, sizeof(szTemp4));
		memset(szTemp5, 0, sizeof(szTemp5));
		wub_hex_2_str(srTransRec.szExpireDate, szTemp,EXPIRY_DATE_BCD_SIZE);
		DebugAddSTR("EXP",szTemp,12);  
		
		for (i =0; i<4;i++)
			szTemp[i] = '*';
		memcpy(szTemp4,&szTemp[0],2);
		memcpy(szTemp5,&szTemp[2],2);

		if(srTransRec.byEntryMode==CARD_ENTRY_ICC)
			memcpy(szTemp1,"ICC",4);
		else if(srTransRec.byEntryMode==CARD_ENTRY_MANUAL)
			memcpy(szTemp1,"Manual",6);
		else if(srTransRec.byEntryMode==CARD_ENTRY_MSR)
			memcpy(szTemp1,"MSR",3);
		else if(srTransRec.byEntryMode==CARD_ENTRY_FALLBACK)
			memcpy(szTemp1,"Fallback",8);
		else if(srTransRec.byEntryMode==CARD_ENTRY_WAVE)
		{
			if ('4' ==srTransRec.szPAN[0])
				memcpy(szTemp1,"CONTACTLESS",7);
			if ('5' ==srTransRec.szPAN[0])
				memcpy(szTemp1,"CONTACTLESS",7);
		}
		
		memset (baTemp, 0x00, sizeof(baTemp));
		sprintf(szTemp,"%s%s/%s          %s%s","EXP: ",szTemp4,szTemp5,"ENT:",szTemp1);
		
		DebugAddSTR("ENT:",baTemp,12);  
		CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szTemp, &stgFONT_ATTRIB);
		CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
#else
		printCardHolderNameEntryMode();

#endif

        //Reference num
        if(strCDT.inType != DEBIT_CARD)
        {
        
            memset(szStr, ' ', d_LINE_SIZE);
            memset (baTemp, 0x00, sizeof(baTemp));					
            memset(szStr, ' ', d_LINE_SIZE);
            sprintf(szStr, "REF NO.   : %s", srTransRec.szRRN);
           // memset (baTemp, 0x00, sizeof(baTemp));		
            //CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            //CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

			
        }
		//Auth response code
		// #00158 No Account type printed on DEBIT receipt			
        if(strCDT.inType == DEBIT_CARD)
	{
		char szTemp[100+1];
		char szAccntType[40+1];
		memset(szTemp, ' ', sizeof(szTemp));
		memset (baTemp, 0x00, sizeof(baTemp));		
		memset(szAccntType, ' ', sizeof(szAccntType));

		if(srTransRec.inAccountType == CURRENT_ACCOUNT)
			strcpy(szAccntType, "CURRENT");
		else if(srTransRec.inAccountType == SAVINGS_ACCOUNT)
			strcpy(szAccntType, "SAVINGS");

		//memset(szStr, ' ', d_LINE_SIZE);
		//sprintf(szStr, "APPR. CODE: %s", srTransRec.szAuthCode);
		sprintf(szTemp, "APPR. CODE: %s   ACCNT TYPE:  %s", srTransRec.szAuthCode, szAccntType);
		memset (baTemp, 0x00, sizeof(baTemp));		
		CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szTemp, &stgFONT_ATTRIB);
		CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);		
	}	
	else
	{

		memset(szStr2, ' ', d_LINE_SIZE);
		sprintf(szStr2, "APPR. CODE: %s", srTransRec.szAuthCode);
		//memset (baTemp, 0x00, sizeof(baTemp));		
		//CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		//CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);	
	inPrintLeftRight(szStr, szStr2, 46);
		
	}


		
	//Terminal serial number - mfl		
	memset(szTemp, ' ', d_LINE_SIZE);
    	memset (baTemp, 0x00, sizeof(baTemp));			
	memset(szTermSerialNum, 0x00, sizeof(szTermSerialNum)); 
	CTOS_GetFactorySN(szTermSerialNum);		 
			szTermSerialNum[15]=0;
	
	//sprintf(szStr, "TERMINAL SERIAL NUM: %s", szTermSerialNum);
	sprintf(szStr, "TSN: %s", szTermSerialNum);		 
         CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
         result = CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
	CTOS_PrinterFline(d_LINE_DOT * 1); // space after printing trans title.
		 
	//

#if 0
		CTOS_PrinterFline(d_LINE_DOT * 1); // space after printing trans title.
		
		memset(szStr, ' ', d_LINE_SIZE);
		memset(szTemp, ' ', d_LINE_SIZE);
							
		//																			include tap/ ctls print out
		//if(srTransRec.byEntryMode == CARD_ENTRY_ICC && srTransRec.byTransType != REFUND || srTransRec.byEntryMode == CARD_ENTRY_WAVE && srTransRec.byTransType != REFUND)
		//{

//    	fix for issue Remove EMV data on chip VOID refund transaction
        	if(srTransRec.byEntryMode == CARD_ENTRY_ICC || srTransRec.byEntryMode == CARD_ENTRY_WAVE)
        	{
				//AID
				memset(szStr, ' ', d_LINE_SIZE);
				EMVtagLen = srTransRec.stEMVinfo.T84_len;
				memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
				memcpy(EMVtagVal, srTransRec.stEMVinfo.T84, EMVtagLen);
				memset(szTemp, ' ', d_LINE_SIZE);
				wub_hex_2_str(EMVtagVal, szTemp, EMVtagLen);
				sprintf(szStr, "AID       : %s",szTemp);
				//memset (baTemp, 0x00, sizeof(baTemp));		
				//CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				//CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);


				memset(baTemp, ' ', d_LINE_SIZE);
				//sprintf(szStr, "APP LABEL : %s", srTransRec.stEMVinfo.szChipLabel);
				sprintf(baTemp, "APP : %s", srTransRec.stEMVinfo.szChipLabel);
				//memset (baTemp, 0x00, sizeof(baTemp));		
				//CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				//CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

				inPrintLeftRight(szStr, baTemp, 46);
        	
		            if(srTransRec.byTransType != REFUND && srTransRec.byOrgTransType != REFUND)
		            {
		                //AC
				memset(szStr, ' ', d_LINE_SIZE);		                
		                wub_hex_2_str(srTransRec.stEMVinfo.T9F26, szTemp, 8);
		                //sprintf(szStr, "APP CRYPT : %s", szTemp);
		                sprintf(szStr, "TC : %s", szTemp);
		                //memset (baTemp, 0x00, sizeof(baTemp));		
		                //CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		                //CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);	   
		                
		                //TVR
		                EMVtagLen = 5;
		                memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
		                memcpy(EMVtagVal, srTransRec.stEMVinfo.T95, EMVtagLen);
		                memset(baTemp, ' ', d_LINE_SIZE);
		                //sprintf(szStr, "TVR VALUE : %02x%02x%02x%02x%02x", EMVtagVal[0], EMVtagVal[1], EMVtagVal[2], EMVtagVal[3], EMVtagVal[4]);
		                sprintf(baTemp, "TVR : %02x%02x%02x%02x%02x", EMVtagVal[0], EMVtagVal[1], EMVtagVal[2], EMVtagVal[3], EMVtagVal[4]);
		                //memset (baTemp, 0x00, sizeof(baTemp));		
		                //CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		                //CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

				inPrintLeftRight(szStr, baTemp, 46);
						
		            }
					
		
		}
#endif		
		memset(szStr, ' ', d_LINE_SIZE);
		memset(szTemp, ' ', d_LINE_SIZE);
		memset(szTemp1, ' ', d_LINE_SIZE);
		memset(szTemp3, ' ', d_LINE_SIZE);
		wub_hex_2_str(srTransRec.szTotalAmount, szTemp, AMT_BCD_SIZE);
		wub_hex_2_str(srTransRec.szBaseAmount, szTemp1, AMT_BCD_SIZE);

        //vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
        vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
        

#if 0
{
	char szTerms[20+1];
	memset(szTerms,0x00,sizeof(szTerms));
	sprintf(szTerms, "ushCTOS_PrintBody::%d:%d", srTransRec.byTransType, srTransRec.byPackType);
	CTOS_PrinterPutString(szTerms);
	
}
#endif	

																										//fix for #00111 Tip is printed on Void Refund
		if ((srTransRec.byTransType == SALE || srTransRec.byTransType == VOID ||srTransRec.byTransType == SALE_OFFLINE)&&(srTransRec.byPackType != VOID_REFUND))
		{
			//int shHostIndex;
		    	//shHostIndex=strHDT.inHostIndex;
		    	//inHDTRead(19); //fix for No TIP and total amount printed on duplicate receipt issue. 2.#00021 - Tip amount is not included in the receipt.
		
	    //CTOS_PrinterPutString("ushCTOS_PrintBody-1");
			
	            if(srTransRec.fInstallment || srTransRec.fCash2Go)
	            {
	//    CTOS_PrinterPutString("ushCTOS_PrintBody");
	            
	                ushCTOS_PrintInstallmentDetails();				
	            }
			else
			{
//    CTOS_PrinterPutString("ushCTOS_PrintBody-2");
			
                //Tip amount
                memset(szStr, ' ', d_LINE_SIZE);
                sprintf(szStr,"%s    %s","TIP",strCST.szCurSymbol);
                memset (baTemp, 0x00, sizeof(baTemp));
                memset (szTemp4, 0x00, sizeof(szTemp4));
                wub_hex_2_str(srTransRec.szTipAmount, szTemp4, AMT_BCD_SIZE);
                
                DebugAddSTR("TIP:",szTemp4,12);

#if 0
{
	char szTerms[20+1];
	memset(szTerms,0x00,sizeof(szTerms));
	sprintf(szTerms, "ushCTOS_PrintBody::[%d]", srTransRec.byOrgTransType);
	CTOS_PrinterPutString(szTerms);
	
}
#endif	

				//#00157 Debit transaction has tipping amount on receipt.
                if (TRUE ==strHDT.fTipAllowFlag && strCDT.inType != DEBIT_CARD 
					&& srTransRec.byOrgTransType != PRE_COMP
					&& srTransRec.byOrgTransType != CASH_ADV)
                {
                	//srTransRec.fTipAllowFlag = 1;
//    CTOS_PrinterPutString("ushCTOS_PrintBody-3");
                        vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
			//Base amount
			vdPrintFormattedAmount("AMOUNT:", szTemp1, 24);
					
                    					
                    if(atol(szTemp4) > 0)
                    {
                        vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
                    
                        vdPrintFormattedAmount("TIP   :", szTemp4, 24);
                        
                        //Total amount
                        vdPrintFormattedAmount("TOTAL :", szTemp, 24);
                    }
                    else
                    {
                        memset(szStr, ' ', d_LINE_SIZE);
                        sprintf(szStr, "TIP   :%s____________________", strCST.szCurSymbol); // 07222015
                        
                        CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
                        CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
                        //CTOS_PrinterPutString("                 ____________________");
                        
                        //Total amount
                        memset(szStr, ' ', d_LINE_SIZE);
                        sprintf(szStr, "TOTAL :%s____________________", strCST.szCurSymbol);
                        memset (baTemp, 0x00, sizeof(baTemp));
                        CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
                        CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
                        //CTOS_PrinterPutString("                 ____________________");
                    }
                }
			else{
                        vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);				
                    vdPrintFormattedAmount("TOTAL :", szTemp1, 24);		
				}
			}
			
		}
		else if (srTransRec.byTransType == SALE_TIP)
		{
			memset(szTemp3, ' ', d_LINE_SIZE);
			wub_hex_2_str(srTransRec.szTipAmount, szTemp3, AMT_BCD_SIZE);
			//vdPrintFormattedAmount("AMOUNT:", szTemp1, 24);
                        vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
			vdPrintFormattedAmount("AMOUNT:", szTemp1, 24);
			vdPrintFormattedAmount("TIPS  :", szTemp3, 24);
			//CTOS_PrinterPutString("                 ____________________");
			vdPrintFormattedAmount("TOTAL :", szTemp, 24);
			//CTOS_PrinterPutString("                 ____________________");
			
		}
		else
		{			
            //vdPrintFormattedAmount("AMOUNT:", szTemp, 24);
                        vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
			vdPrintFormattedAmount("AMOUNT:", szTemp1, 24);
        		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
            
		}


	// #00060 - start - Revision on Chip Receipt:
#if 1
		//CTOS_PrinterFline(d_LINE_DOT * 1); // space after printing trans title.
		
		memset(szStr, ' ', d_LINE_SIZE);
		memset(szTemp, ' ', d_LINE_SIZE);
							
		//																			include tap/ ctls print out
		//if(srTransRec.byEntryMode == CARD_ENTRY_ICC && srTransRec.byTransType != REFUND || srTransRec.byEntryMode == CARD_ENTRY_WAVE && srTransRec.byTransType != REFUND)
		//{

//    	fix for issue Remove EMV data on chip VOID refund transaction
        	if(srTransRec.byEntryMode == CARD_ENTRY_ICC || srTransRec.byEntryMode == CARD_ENTRY_WAVE)
        	{
		CTOS_PrinterFline(d_LINE_DOT * 1); // space after printing trans title.
        	
        		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
        	
				//AID
				memset(szStr, ' ', d_LINE_SIZE);
				EMVtagLen = srTransRec.stEMVinfo.T84_len;
				memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
				memcpy(EMVtagVal, srTransRec.stEMVinfo.T84, EMVtagLen);
				memset(szTemp, ' ', d_LINE_SIZE);
				wub_hex_2_str(EMVtagVal, szTemp, EMVtagLen);
				sprintf(szStr, "AID: %s",szTemp);
				//memset (baTemp, 0x00, sizeof(baTemp));		
				//CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				//CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);


				memset(baTemp, ' ', d_LINE_SIZE);
				//sprintf(szStr, "APP LABEL : %s", srTransRec.stEMVinfo.szChipLabel);
				sprintf(baTemp, "APP: %s", srTransRec.stEMVinfo.szChipLabel);
				//memset (baTemp, 0x00, sizeof(baTemp));		
				//CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				//CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

				inPrintLeftRight(szStr, baTemp, 46);
        	
		            if(srTransRec.byTransType != REFUND && srTransRec.byOrgTransType != REFUND)
		            {
		                //AC
				memset(szStr, ' ', d_LINE_SIZE);		                
		                wub_hex_2_str(srTransRec.stEMVinfo.T9F26, szTemp, 8);
		                //sprintf(szStr, "APP CRYPT : %s", szTemp);
		                sprintf(szStr, "TC: %s", szTemp);
		                //memset (baTemp, 0x00, sizeof(baTemp));		
		                //CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		                //CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);	   
		                
		                //TVR
		                EMVtagLen = 5;
		                memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
		                memcpy(EMVtagVal, srTransRec.stEMVinfo.T95, EMVtagLen);
		                memset(baTemp, ' ', d_LINE_SIZE);
		                //sprintf(szStr, "TVR VALUE : %02x%02x%02x%02x%02x", EMVtagVal[0], EMVtagVal[1], EMVtagVal[2], EMVtagVal[3], EMVtagVal[4]);
		                sprintf(baTemp, "TVR: %02x%02x%02x%02x%02x", EMVtagVal[0], EMVtagVal[1], EMVtagVal[2], EMVtagVal[3], EMVtagVal[4]);
		                //memset (baTemp, 0x00, sizeof(baTemp));		
		                //CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		                //CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

				inPrintLeftRight(szStr, baTemp, 46);
						
		            }
					
		
		}
#endif		

	
	// #00060 - end

        //vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);
	}
	else if(d_SECOND_PAGE == page || d_THIRD_PAGE == page)
	{
    	//memset(szTemp1, ' ', d_LINE_SIZE);
    	//sprintf(szTemp1,"%s",srTransRec.szHostLabel);
    	//vdPrintCenter(szTemp1);
   	//CTOS_PrinterPutString("2ND PAGE");

		// - print adjustment 07132015
		szGetTransTitle(srTransRec.byTransType, szStr);     
		inPrint(szStr);   
		// - print adjustment 07132015
    	
		
		printDateTime();
		inResult = printTIDMID(); 

		printBatchInvoiceNO(); // pat confirm hang

		//memset(szStr, ' ', d_LINE_SIZE);
		//szGetTransTitle(srTransRec.byTransType, szStr);     
		//vdPrintTitleCenter(szStr);    

		//CTOS_PrinterFline(d_LINE_DOT * 1); // space after printing trans title.

		//vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
    vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
		
		memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
		EMVtagLen = 0;
#if 0		
		memset(szStr, ' ', d_LINE_SIZE);
		vdMyEZLib_LogPrintf("CDT index: %d",srTransRec.CDTid);

		sprintf(szStr, "%s", srTransRec.szCardLable);
		vdMyEZLib_LogPrintf("Card label: %s",srTransRec.szCardLable);
		
		memset (baTemp, 0x00, sizeof(baTemp));
		CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 

		//cardMasking(srTransRec.szPAN, PRINT_CARD_MASKING_1);
		//strcpy(szTemp4, srTransRec.szPAN);
		//memset (baTemp, 0x00, sizeof(baTemp));
		//CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szTemp4, &stgFONT_ATTRIB);
		//CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);		

        memset (baTemp, 0x00, sizeof(baTemp));
		vdCTOS_FormatPAN(strIIT.szMaskCustomerCopy, srTransRec.szPAN, baTemp);
        inPrint(baTemp);
#else // print CARD LABEL AND CARD NUMBER
		memset(szStr, ' ', d_LINE_SIZE);
		//sprintf(szStr, "%s", srTransRec.szCardLable);
		 if(strcmp(srTransRec.szCardLable, "BANCNET") == 0) //#00232 - When card process as DEBIT SALE terminal prints BANCNET instead of MCC DEBIT
		 		strcpy(szStr,"MCC DEBIT");    
		 else
				sprintf(szStr, "%s", srTransRec.szCardLable);

        	memset (baTemp, 0x00, sizeof(baTemp));
		vdCTOS_FormatPAN(strIIT.szMaskCustomerCopy, srTransRec.szPAN, baTemp);

		inPrintLeftRight(szStr, baTemp, 46);

#endif		

		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
#if 0
		printCardHolderName();
        
		//Exp date and Entry mode
		memset(szStr, ' ', d_LINE_SIZE);
		memset(szTemp, 0, sizeof(szTemp));
		memset(szTemp1, 0, sizeof(szTemp1));
		memset(szTemp4, 0, sizeof(szTemp4));
		memset(szTemp5, 0, sizeof(szTemp5));
		wub_hex_2_str(srTransRec.szExpireDate, szTemp,EXPIRY_DATE_BCD_SIZE);
		DebugAddSTR("EXP",szTemp,12);  
		
		for (i =0; i<4;i++)
			szTemp[i] = '*';
		memcpy(szTemp4,&szTemp[0],2);
		memcpy(szTemp5,&szTemp[2],2);

		if(srTransRec.byEntryMode==CARD_ENTRY_ICC)
			memcpy(szTemp1,"ICC",4);
		else if(srTransRec.byEntryMode==CARD_ENTRY_MANUAL)
			memcpy(szTemp1,"Manual",6);
		else if(srTransRec.byEntryMode==CARD_ENTRY_MSR)
			memcpy(szTemp1,"MSR",3);
		else if(srTransRec.byEntryMode==CARD_ENTRY_FALLBACK)
			memcpy(szTemp1,"Fallback",8);
		
		DebugAddSTR("ENT:",szTemp1,12);  
		memset (baTemp, 0x00, sizeof(baTemp));

		memset (baTemp, 0x00, sizeof(baTemp));
		sprintf(szTemp,"%s%s/%s          %s%s","EXP: ",szTemp4,szTemp5,"ENT:",szTemp1);
		
		DebugAddSTR("ENT:",baTemp,12);  
		CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szTemp, &stgFONT_ATTRIB);
		CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
#else
		printCardHolderNameEntryMode();
#endif

        //Reference num
        if(strCDT.inType != DEBIT_CARD)
        {
            memset(szStr, ' ', d_LINE_SIZE);
            memset (baTemp, 0x00, sizeof(baTemp));					
            memset(szStr, ' ', d_LINE_SIZE);
            sprintf(szStr, "REF NO.   : %s", srTransRec.szRRN);
            //memset (baTemp, 0x00, sizeof(baTemp));		
            //CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            //CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

			
        }

		//Auth response code
		// #00158 No Account type printed on DEBIT receipt			

        if(strCDT.inType == DEBIT_CARD)
	{
		char szTemp[100+1];
		char szAccntType[40+1];
		memset(szTemp, ' ', sizeof(szTemp));
		memset (baTemp, 0x00, sizeof(baTemp));		
		memset(szAccntType, ' ', sizeof(szAccntType));

		if(srTransRec.inAccountType == CURRENT_ACCOUNT)
			strcpy(szAccntType, "CURRENT");
		else if(srTransRec.inAccountType == SAVINGS_ACCOUNT)
			strcpy(szAccntType, "SAVINGS");

		//memset(szStr, ' ', d_LINE_SIZE);
		//sprintf(szStr, "APPR. CODE: %s", srTransRec.szAuthCode);
		sprintf(szTemp, "APPR. CODE: %s   ACCNT TYPE:  %s", srTransRec.szAuthCode, szAccntType);
		memset (baTemp, 0x00, sizeof(baTemp));		
		CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szTemp, &stgFONT_ATTRIB);
		CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);		
	}	
	else
	{

		memset(szStr2, ' ', d_LINE_SIZE);
		sprintf(szStr2, "APPR. CODE: %s", srTransRec.szAuthCode);
		//memset (baTemp, 0x00, sizeof(baTemp));		
		//CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		//CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);		
	inPrintLeftRight(szStr, szStr2, 46);
		
		
	}

		
	//Terminal serial number - mfl		
	memset(szTemp, ' ', d_LINE_SIZE);
    	memset (baTemp, 0x00, sizeof(baTemp));			
	memset(szTermSerialNum, 0x00, sizeof(szTermSerialNum)); 
	CTOS_GetFactorySN(szTermSerialNum);		 
			szTermSerialNum[15]=0;
	
	//sprintf(szStr, "TERMINAL SERIAL NUM: %s", szTermSerialNum);
	 sprintf(szStr, "TSN: %s", szTermSerialNum);
	
         CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
         result = CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
	CTOS_PrinterFline(d_LINE_DOT * 1); // space after printing trans title.
		 
	//

#if 0	
		CTOS_PrinterFline(d_LINE_DOT * 1); // space after printing trans title.
		
		memset(szStr, ' ', d_LINE_SIZE);
		memset(szTemp, ' ', d_LINE_SIZE);
		//if(srTransRec.byEntryMode == CARD_ENTRY_ICC && srTransRec.byTransType != REFUND || srTransRec.byEntryMode == CARD_ENTRY_WAVE && srTransRec.byTransType != REFUND)
		//{
//    	fix for issue Remove EMV data on chip VOID refund transaction
        	if(srTransRec.byEntryMode == CARD_ENTRY_ICC || srTransRec.byEntryMode == CARD_ENTRY_WAVE)
        	{
				//AID
				memset(szStr, ' ', d_LINE_SIZE);
				EMVtagLen = srTransRec.stEMVinfo.T84_len;
				memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
				memcpy(EMVtagVal, srTransRec.stEMVinfo.T84, EMVtagLen);
				memset(szTemp, ' ', d_LINE_SIZE);
				wub_hex_2_str(EMVtagVal, szTemp, EMVtagLen);
				sprintf(szStr, "AID       : %s",szTemp);
				//memset (baTemp, 0x00, sizeof(baTemp));		
				//CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				//CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);


				memset(baTemp, ' ', d_LINE_SIZE);
				//sprintf(szStr, "APP LABEL : %s", srTransRec.stEMVinfo.szChipLabel);
				sprintf(baTemp, "APP : %s", srTransRec.stEMVinfo.szChipLabel);
				//memset (baTemp, 0x00, sizeof(baTemp));		
				//CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				//CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

				inPrintLeftRight(szStr, baTemp, 46);
        	
		            if(srTransRec.byTransType != REFUND && srTransRec.byOrgTransType != REFUND)
		            {
		                //AC
				memset(szStr, ' ', d_LINE_SIZE);		                
		                wub_hex_2_str(srTransRec.stEMVinfo.T9F26, szTemp, 8);
		                //sprintf(szStr, "APP CRYPT : %s", szTemp);
		                sprintf(szStr, "TC : %s", szTemp);
		                //memset (baTemp, 0x00, sizeof(baTemp));		
		                //CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		                //CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);	   
		                
		                //TVR
		                EMVtagLen = 5;
		                memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
		                memcpy(EMVtagVal, srTransRec.stEMVinfo.T95, EMVtagLen);
		                memset(baTemp, ' ', d_LINE_SIZE);
		                //sprintf(szStr, "TVR VALUE : %02x%02x%02x%02x%02x", EMVtagVal[0], EMVtagVal[1], EMVtagVal[2], EMVtagVal[3], EMVtagVal[4]);
		                sprintf(baTemp, "TVR : %02x%02x%02x%02x%02x", EMVtagVal[0], EMVtagVal[1], EMVtagVal[2], EMVtagVal[3], EMVtagVal[4]);
		                //memset (baTemp, 0x00, sizeof(baTemp));		
		                //CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		                //CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

				inPrintLeftRight(szStr, baTemp, 46);
						
		            }

					
		}
#endif		
		memset(szStr, ' ', d_LINE_SIZE);
		memset(szTemp, ' ', d_LINE_SIZE);
		memset(szTemp1, ' ', d_LINE_SIZE);
		memset(szTemp3, ' ', d_LINE_SIZE);
		wub_hex_2_str(srTransRec.szTotalAmount, szTemp, AMT_BCD_SIZE);
		wub_hex_2_str(srTransRec.szBaseAmount, szTemp1, AMT_BCD_SIZE);

        //vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
    vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
        
		//if (srTransRec.byTransType == SALE || srTransRec.byTransType == VOID || srTransRec.byTransType == SALE_OFFLINE)
		if ((srTransRec.byTransType == SALE || srTransRec.byTransType == VOID ||srTransRec.byTransType == SALE_OFFLINE)&&(srTransRec.byPackType != VOID_REFUND))	
		{

    //CTOS_PrinterPutString("ushCTOS_PrintBody-2");
		
			//Base amount
            if(srTransRec.fInstallment || srTransRec.fCash2Go)
            {
                ushCTOS_PrintInstallmentDetails();				
            }
			else
			{
    			//Tip amount
    			memset(szStr, ' ', d_LINE_SIZE);
    			sprintf(szStr,"%s    %s","TIP",strCST.szCurSymbol);
    			memset (baTemp, 0x00, sizeof(baTemp));
    			memset (szTemp4, 0x00, sizeof(szTemp4));
    			wub_hex_2_str(srTransRec.szTipAmount, szTemp4, AMT_BCD_SIZE);
    
    			DebugAddSTR("TIP:",szTemp4,12);

				
				//#00157 Debit transaction has tipping amount on receipt.				
                //if (TRUE ==strHDT.fTipAllowFlag && strCDT.inType != DEBIT_CARD)
                if (TRUE ==strHDT.fTipAllowFlag && strCDT.inType != DEBIT_CARD 
					&& srTransRec.byOrgTransType != PRE_COMP
					&& srTransRec.byOrgTransType != CASH_ADV)                
                {
					//Base amount
					//vdPrintFormattedAmount("AMOUNT:", szTemp1, 24);
                        vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
			vdPrintFormattedAmount("AMOUNT:", szTemp1, 24);

                    if(atol(szTemp4) > 0)
                    {
                        vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
                    
                        vdPrintFormattedAmount("TIP   :", szTemp4, 24);
                        
                        //Total amount
                        vdPrintFormattedAmount("TOTAL :", szTemp, 24);
                    }
                    else
                    {
                        memset(szStr, ' ', d_LINE_SIZE);
                        sprintf(szStr, "TIP   :%s____________________", strCST.szCurSymbol); // 07222015
                        
                        CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
                        CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
                        //CTOS_PrinterPutString("                 ____________________");
                        
                        //Total amount
                        memset(szStr, ' ', d_LINE_SIZE);
                        sprintf(szStr, "TOTAL :%s____________________", strCST.szCurSymbol);
                        memset (baTemp, 0x00, sizeof(baTemp));
                        CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
                        CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
                        //CTOS_PrinterPutString("                 ____________________");
                    }
                }
				else{
                        vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
					
    		        vdPrintFormattedAmount("TOTAL :", szTemp1, 24);
					}
			}
		}
		else if (srTransRec.byTransType == SALE_TIP)
		{
			memset(szTemp3, ' ', d_LINE_SIZE);
			wub_hex_2_str(srTransRec.szTipAmount, szTemp3, AMT_BCD_SIZE);
			//vdPrintFormattedAmount("AMOUNT:", szTemp1, 24);
                        vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
			vdPrintFormattedAmount("AMOUNT:", szTemp1, 24);
			vdPrintFormattedAmount("TIPS  :", szTemp3, 24);
			//CTOS_PrinterPutString("                 ____________________");
			vdPrintFormattedAmount("TOTAL :", szTemp, 24);
			//CTOS_PrinterPutString("                 ____________________");
		}
		else
		{
                        vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);		
            vdPrintFormattedAmount("TOTAL :", szTemp, 24);
		}

// #00060 - start - Revision on Chip Receipt:
#if 1
        	vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);

		memset(szStr, ' ', d_LINE_SIZE);
		memset(szTemp, ' ', d_LINE_SIZE);
							
		//																			include tap/ ctls print out
		//if(srTransRec.byEntryMode == CARD_ENTRY_ICC && srTransRec.byTransType != REFUND || srTransRec.byEntryMode == CARD_ENTRY_WAVE && srTransRec.byTransType != REFUND)
		//{

//    	fix for issue Remove EMV data on chip VOID refund transaction
        	if(srTransRec.byEntryMode == CARD_ENTRY_ICC || srTransRec.byEntryMode == CARD_ENTRY_WAVE)
        	{
		CTOS_PrinterFline(d_LINE_DOT * 1); // space after printing trans title.		
        	
        		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
        	
				//AID
				memset(szStr, ' ', d_LINE_SIZE);
				EMVtagLen = srTransRec.stEMVinfo.T84_len;
				memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
				memcpy(EMVtagVal, srTransRec.stEMVinfo.T84, EMVtagLen);
				memset(szTemp, ' ', d_LINE_SIZE);
				wub_hex_2_str(EMVtagVal, szTemp, EMVtagLen);
				sprintf(szStr, "AID: %s",szTemp);
				//memset (baTemp, 0x00, sizeof(baTemp));		
				//CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				//CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);


				memset(baTemp, ' ', d_LINE_SIZE);
				//sprintf(szStr, "APP LABEL : %s", srTransRec.stEMVinfo.szChipLabel);
				sprintf(baTemp, "APP: %s", srTransRec.stEMVinfo.szChipLabel);
				//memset (baTemp, 0x00, sizeof(baTemp));		
				//CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				//CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

				inPrintLeftRight(szStr, baTemp, 46);
        	
		            if(srTransRec.byTransType != REFUND && srTransRec.byOrgTransType != REFUND)
		            {
		                //AC
				memset(szStr, ' ', d_LINE_SIZE);		                
		                wub_hex_2_str(srTransRec.stEMVinfo.T9F26, szTemp, 8);
		                //sprintf(szStr, "APP CRYPT : %s", szTemp);
		                sprintf(szStr, "TC: %s", szTemp);
		                //memset (baTemp, 0x00, sizeof(baTemp));		
		                //CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		                //CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);	   
		                
		                //TVR
		                EMVtagLen = 5;
		                memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
		                memcpy(EMVtagVal, srTransRec.stEMVinfo.T95, EMVtagLen);
		                memset(baTemp, ' ', d_LINE_SIZE);
		                //sprintf(szStr, "TVR VALUE : %02x%02x%02x%02x%02x", EMVtagVal[0], EMVtagVal[1], EMVtagVal[2], EMVtagVal[3], EMVtagVal[4]);
		                sprintf(baTemp, "TVR: %02x%02x%02x%02x%02x", EMVtagVal[0], EMVtagVal[1], EMVtagVal[2], EMVtagVal[3], EMVtagVal[4]);
		                //memset (baTemp, 0x00, sizeof(baTemp));		
		                //CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		                //CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

				inPrintLeftRight(szStr, baTemp, 46);
						
		            }
					
		
		}
#endif		
//#00060 - end        
	}

    //CTOS_PrinterPutString("ushCTOS_PrintBody-end");
	
	return d_OK;	
	
}
USHORT ushCTOS_PrintAgreement()
{
    if(strCDT.inType != DEBIT_CARD)
    {
        vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
        vdPrintCenter("I AGREE TO PAY THE ABOVE TOTAL AMOUNT");
        vdPrintCenter("ACCORDING TO THE CARD ISSUER AGREEMENT");
		CTOS_PrinterFline(d_LINE_DOT * 1);
        vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, NORMAL_SIZE, 0, 0);
    }
}

USHORT ushCTOS_PrintFooter(int page)
{		
    BYTE   EMVtagVal[64];
    USHORT EMVtagLen; 

//	inPrint("ushCTOS_PrintFooter");
	
	vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
	if(page == d_FIRST_PAGE)
	{
//	inPrint("ushCTOS_PrintFooter-1");
	
		memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
		EMVtagLen = 0;
		
		DebugAddINT("ushCTOS_PrintFooter,mode",srTransRec.byEntryMode);  
		if(srTransRec.byEntryMode==CARD_ENTRY_ICC)
		{
		    EMVtagLen = 3;
            memcpy(EMVtagVal, srTransRec.stEMVinfo.T9F34, EMVtagLen);
			if((EMVtagVal[2]& 0x0F) == 2)
            {   
                CTOS_PrinterFline(d_LINE_DOT * 1);
                CTOS_PrinterPutString("*****NO SIGNATURE REQUIRED*****");
                CTOS_PrinterPutString("     (PIN VERIFY SUCCESS)");
            }
            else
            {
                //CTOS_PrinterFline(d_LINE_DOT * 3);
            }
		}
        else
        {
            //CTOS_PrinterFline(d_LINE_DOT * 3);
        }

		ushCTOS_ePadPrintSignature();
		
		//CTOS_PrinterPutString("SIGN:_______________________________________");
		//printCardHolderName();
		CTOS_PrinterFline(d_LINE_DOT * 1);
		
		ushCTOS_PrintAgreement();

		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
		if(strlen(strMMT[0].szRctFoot1) > 0)
			vdPrintCenter(strMMT[0].szRctFoot1);
		if(strlen(strMMT[0].szRctFoot2) > 0)
	    	vdPrintCenter(strMMT[0].szRctFoot2);
		if(strlen(strMMT[0].szRctFoot3) > 0)
	    	vdPrintCenter(strMMT[0].szRctFoot3);

		if(strHDT.fFooterLogo == TRUE)	
		{
			if(strlen(strHDT.szFooterLogoName))
				vdCTOSS_PrinterBMPPic(0, 0, strHDT.szFooterLogoName);
			else	
                vdCTOSS_PrinterBMPPic(0, 0, "footer.bmp");
		}
		
		CTOS_PrinterFline(d_LINE_DOT * 1); 
		CTOS_PrinterPutString("   ***** CUSTOMER COPY *****  ");
	}
	else if(page == d_SECOND_PAGE)
	{
//	inPrint("ushCTOS_PrintFooter-2");
	
		memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
		EMVtagLen = 0;
		
		DebugAddINT("ushCTOS_PrintFooter,mode",srTransRec.byEntryMode);  
		if(srTransRec.byEntryMode==CARD_ENTRY_ICC)
		{
			EMVtagLen = 3;
            memcpy(EMVtagVal, srTransRec.stEMVinfo.T9F34, EMVtagLen);
			if((EMVtagVal[2]& 0x0F) == 2)
            {         
                CTOS_PrinterFline(d_LINE_DOT * 1);
                CTOS_PrinterPutString("*****NO SIGNATURE REQUIRED*****");
                CTOS_PrinterPutString("     (PIN VERIFY SUCCESS)");
            }
            else
            {				
				if(strCDT.inType != DEBIT_CARD)
				{
					CTOS_PrinterFline(d_LINE_DOT * 2);
					CTOS_PrinterPutString("SIGN:_______________________________________");
				}
            }
		}
        else
        {
			if(strCDT.inType != DEBIT_CARD)
			{
				CTOS_PrinterFline(d_LINE_DOT * 2);
				CTOS_PrinterPutString("SIGN:_______________________________________");
			}
        }

        ushCTOS_ePadPrintSignature();
        
        //if(strCDT.inType != DEBIT_CARD)
            //CTOS_PrinterPutString("SIGN:_______________________________________");
		//printCardHolderName();
		CTOS_PrinterFline(d_LINE_DOT * 1);
		
		ushCTOS_PrintAgreement();
        
		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
        if(strlen(strMMT[0].szRctFoot1) > 0)
			vdPrintCenter(strMMT[0].szRctFoot1);
		if(strlen(strMMT[0].szRctFoot2) > 0)
	    	vdPrintCenter(strMMT[0].szRctFoot2);
		if(strlen(strMMT[0].szRctFoot3) > 0)
	    	vdPrintCenter(strMMT[0].szRctFoot3);
		
        if(strHDT.fFooterLogo == TRUE)	
        {
        if(strlen(strHDT.szFooterLogoName))
            vdCTOSS_PrinterBMPPic(0, 0, strHDT.szFooterLogoName);
        else    
            vdCTOSS_PrinterBMPPic(0, 0, "footer.bmp");
        }
		CTOS_PrinterFline(d_LINE_DOT * 1); 
		CTOS_PrinterPutString("   ***** MERCHANT COPY *****  ");
	}
	else if(page == d_THIRD_PAGE)
	{
//	inPrint("ushCTOS_PrintFooter-3");
	
		memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
		EMVtagLen = 0;
		
		DebugAddINT("ushCTOS_PrintFooter,mode",srTransRec.byEntryMode);  
		if(srTransRec.byEntryMode==CARD_ENTRY_ICC)
		{
			EMVtagLen = 3;
            memcpy(EMVtagVal, srTransRec.stEMVinfo.T9F34, EMVtagLen);
			if((EMVtagVal[2]& 0x0F) == 2)
            {         
                CTOS_PrinterFline(d_LINE_DOT * 1);
                CTOS_PrinterPutString("*****NO SIGNATURE REQUIRED*****");
                CTOS_PrinterPutString("     (PIN VERIFY SUCCESS)");
            }
            else
            {				
				if(strCDT.inType != DEBIT_CARD)
				{
					CTOS_PrinterFline(d_LINE_DOT * 2);
					CTOS_PrinterPutString("SIGN:_______________________________________");
				}
            }
		}
        else
        {
			if(strCDT.inType != DEBIT_CARD)
			{
				CTOS_PrinterFline(d_LINE_DOT * 2);
				CTOS_PrinterPutString("SIGN:_______________________________________");
			}
        }

        ushCTOS_ePadPrintSignature();
        
        //if(strCDT.inType != DEBIT_CARD)
            //CTOS_PrinterPutString("SIGN:_______________________________________");
		//printCardHolderName();
		CTOS_PrinterFline(d_LINE_DOT * 1);
		
		ushCTOS_PrintAgreement();
		
		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
        if(strlen(strMMT[0].szRctFoot1) > 0)
			vdPrintCenter(strMMT[0].szRctFoot1);
		if(strlen(strMMT[0].szRctFoot2) > 0)
	    	vdPrintCenter(strMMT[0].szRctFoot2);
		if(strlen(strMMT[0].szRctFoot3) > 0)
	    	vdPrintCenter(strMMT[0].szRctFoot3);
		
        if(strHDT.fFooterLogo == TRUE)	
        {
        if(strlen(strHDT.szFooterLogoName))
            vdCTOSS_PrinterBMPPic(0, 0, strHDT.szFooterLogoName);
        else    
            vdCTOSS_PrinterBMPPic(0, 0, "footer.bmp");
        }
		CTOS_PrinterFline(d_LINE_DOT * 1); 
		CTOS_PrinterPutString("   ***** BANK COPY *****  ");
	}

	
	CTOS_PrinterFline(d_LINE_DOT * 9); 

return d_OK;	

}



USHORT ushCTOS_printAll(int page)
{	
	int inResult;
TRANS_DATA_TABLE srTransPara;

    vdDebug_LogPrintf("ushCTOS_printAll");

    if( printCheckPaper()==-1)
    	return -1;

    vdSetPrintThreadStatus(1);

    vdDebug_LogPrintf("ushCTOS_printAll-1");

    if(VS_FALSE == fRePrintFlag)
	    memcpy(strTCT.szLastInvoiceNo,srTransRec.szInvoiceNo,INVOICE_BCD_SIZE);
	
	if((inResult = inTCTSave(1)) != ST_SUCCESS)
    {
		vdDisplayErrorMsg(1, 8, "Update TCT fail");
    }
	
    inCTOS_SelectFont(d_FONT_FNT_MODE,d_FONT_24x24,0," ");
    vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);
    
    CTOS_PrinterSetHeatLevel(4);  

    vdDebug_LogPrintf("ushCTOS_printAll-2");

	ushCTOS_PrintHeader(page);

    vdDebug_LogPrintf("ushCTOS_printAll-3");

//        CTOS_PrinterPutString("ushCTOS_printAll");
   // 	CTOS_PrinterPutString(srTransRec.szTerms);

	//fix for issue Terminal should prnt VOID OFFLINE AND VOID SALE TIP ADJUST TRANSACTION - added VOID_REDEEM to condition.
	//if(srTransRec.fLoyalty == TRUE && srTransRec.byTransType == LOY_BAL_INQ || srTransRec.byTransType == LOY_REDEEM_5050
	//|| srTransRec.byTransType == LOY_REDEEM_VARIABLE || srTransPara.byPackType == VOID_REDEEM)//srTransRec.byTransType == VOID)	
	if(srTransRec.fLoyalty == TRUE && srTransRec.byTransType == LOY_BAL_INQ || srTransRec.byTransType == LOY_REDEEM_5050
	|| srTransRec.byTransType == LOY_REDEEM_VARIABLE)
	{
	
 	    ushCTOS_PrintLoyaltyBody(page);	
	    ushCTOS_PrintLoyaltyFooter(page);

	}// fix for wrong void redeem printout
	else if(srTransRec.byTransType == VOID && srTransRec.byOrgTransType == LOY_REDEEM_VARIABLE || srTransRec.byOrgTransType == LOY_REDEEM_5050)
	{
//	inPrint("ushCTOS_printAll-1");
	
 	    ushCTOS_PrintLoyaltyBody(page);	
	    ushCTOS_PrintLoyaltyFooter(page);		
	}
	else
	{	
//	inPrint("ushCTOS_printAll-2");
	
  	    ushCTOS_PrintBody(page);	
	    ushCTOS_PrintFooter(page);
	}


    vdSetPrintThreadStatus(0);
   //CTOS_LCDTClearDisplay();  
    
    return d_OK;
 
}

int inCTOS_rePrintReceipt(void)
{
	int   inResult;
	BYTE  szInvNoAsc[6+1];
	BYTE  szInvNoBcd[3];	
	BOOL   needSecond = TRUE;	
	BYTE   key;

//    	CTOS_PrinterPutString("inCTOS_rePrintReceipt");
	
	CTOS_PrinterSetHeatLevel(4);
	if( printCheckPaper()==-1)
		return d_NO;
	
	inResult = inCTOS_GeneralGetInvoice();
	
	if(d_OK != inResult)
	{
		return inResult;
	}

	if (inMultiAP_CheckMainAPStatus() == d_OK)
	{
		inResult = inCTOS_MultiAPBatchSearch(d_IPC_CMD_REPRINT_ANY);
		if(d_OK != inResult)
			return inResult;
	}
	else
	{
		if (inMultiAP_CheckSubAPStatus() == d_OK)
		{
			inResult = inCTOS_MultiAPGetVoid();
			if(d_OK != inResult)
				return inResult;
		}		
		inResult = inCTOS_BatchSearch();
		if(d_OK != inResult)
			return inResult;
	}

	if(d_OK != inResult)
	{
		return inResult;
	}

    inIITRead(srTransRec.IITid);
    inCDTRead(srTransRec.CDTid);
    inHDTRead(srTransRec.HDTid);////fix for No TIP and total amount printed on duplicate receipt issue. 2.#00021 - Tip amount is not included in the receipt.

	inTCTRead(1);

	inResult = ushCTOS_printAll(d_FIRST_PAGE);
	if(inResult == d_OK )
	{
    if(strTCT.fPrintMerchCopy == TRUE)
	{
	
		CTOS_TimeOutSet(TIMER_ID_1, UI_TIMEOUT);  

		vduiDisplayStringCenter(7,"MERCHANT COPY");
		vduiDisplayStringCenter(8,"NO[X] YES[OK]");

		while(1)
		{ 
			vduiWarningSound();
			
			CTOS_KBDHit(&key);
			if(key == d_KBD_ENTER)
			{
				break;
			}
			else if((key == d_KBD_CANCEL))
			{
				needSecond = FALSE;
				break;
			}
			if(CTOS_TimeOutCheck(TIMER_ID_1) == d_YES)
			{
				break;
			}		
		}
		
		if(needSecond)
		{
			inResult = ushCTOS_printAll(d_SECOND_PAGE);
		}
		}
	}

    if(strTCT.fPrintBankCopy == TRUE)
	{
		CTOS_TimeOutSet(TIMER_ID_1, UI_TIMEOUT); 
		clearLine(7);
		clearLine(8);
		CTOS_LCDTPrintXY(1, 7, "BANK COPY");
		CTOS_LCDTPrintXY(1, 8, "NO[X] YES[OK]");
        needSecond = TRUE;
		
		while(1)
		{ 
			vduiWarningSound();
			
			CTOS_KBDHit(&key);
			if(key == d_KBD_ENTER)
			{
				break;
			}
			else if((key == d_KBD_CANCEL))
			{
				needSecond = FALSE;
				break;
			}
			if(CTOS_TimeOutCheck(TIMER_ID_1) == d_YES)
			{
				break;
			}		
		}
		
		if(needSecond)
		{
			inResult = ushCTOS_printAll(d_THIRD_PAGE);
		}
	}

	return d_OK;
}

void vdCTOS_PrintSummaryReport()
{
	ACCUM_REC srAccumRec;
	unsigned char chkey;
	short shHostIndex;
	int inResult,inRet;
	int inTranCardType;
	int inReportType;
	int inIITNum , i;
	char szStr[d_LINE_SIZE + 1];
    BYTE baTemp[PAPER_X_SIZE * 64];

//    	CTOS_PrinterPutString("vdCTOS_PrintSummaryReport");

	if( printCheckPaper()==-1)
		return;

	
	//by host and merchant
	shHostIndex = inCTOS_SelectHostSetting();
	if (shHostIndex == -1)
		return;
	strHDT.inHostIndex = shHostIndex;
    
	DebugAddINT("summary host Index",shHostIndex);
	inCSTRead(strHDT.inCurrencyIdx);

	if (inMultiAP_CheckMainAPStatus() == d_OK)
	{
		inRet = inCTOS_MultiAPSaveData(d_IPC_CMD_SUMMARY_REPORT);
		if(d_OK != inRet)
			return ;
	}
	else
	{
		if (inMultiAP_CheckSubAPStatus() == d_OK)
		{
			inRet = inCTOS_MultiAPGetData();
			if(d_OK != inRet)
				return ;

			inRet = inCTOS_MultiAPReloadHost();
			if(d_OK != inRet)
				return ;
		}
	}

	inResult = inCTOS_CheckAndSelectMutipleMID();
	DebugAddINT("summary MITid",srTransRec.MITid);
	if(d_OK != inResult)
		return;

	inResult = inCTOS_ChkBatchEmpty();
	if(d_OK != inResult)
	{
		return;
	}

    memset(&srAccumRec, 0x00, sizeof(ACCUM_REC));
    if((inResult = inCTOS_ReadAccumTotal(&srAccumRec)) == ST_ERROR)
    {
        vdMyEZLib_LogPrintf("[vdUpdateAmountTotal]---Read Total Rec. error");
        return;    
    }

    inCTOS_SelectFont(d_FONT_FNT_MODE,d_FONT_24x24,0," ");
    vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);

	CTOS_PrinterSetHeatLevel(4);
            vdSetPrintThreadStatus(1); //##00129

	ushCTOS_PrintHeader(0);	
    
    vdPrintTitleCenter("SUMMARY REPORT");
	CTOS_PrinterFline(d_LINE_DOT * 1);

    vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);

    printHostLabel();
    
	printTIDMID();

	vdCTOS_SetDateTime();
	
	printDateTime();
    
	printBatchNO();

    CTOS_PrinterFline(d_LINE_DOT * 1);
	for(inTranCardType = 0; inTranCardType < 2 ;inTranCardType ++)
	{
		BOOL fPrintTotal=FALSE;
		inReportType = PRINT_CARD_TOTAL;
		
		if(inReportType == PRINT_CARD_TOTAL)
		{
			for(i= 0; i <20; i ++ )
			{
				vdDebug_LogPrintf("--Count[%d]", i);
				if((srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usSaleCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usOffSaleCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usRedeemCount == 0)	
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usRegularCount== 0)					
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usReduceCount== 0)						
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usZeroCount== 0)				
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usBNPLCount== 0)		
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].us2GOCount== 0)						
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usCashCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usCompCount == 0)		
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usRefundCount == 0)				
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidBNPLCount== 0)												
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoid2GOCount== 0)																
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidSaleCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidRegularCount == 0)		
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidReduceCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidZeroCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidCashCount == 0)				
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidCompCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidRefundCount== 0))
					continue;
				
				vdDebug_LogPrintf("Count[%d]", i); 
				inIITRead(i);
				memset(szStr, ' ', d_LINE_SIZE);
				memset (baTemp, 0x00, sizeof(baTemp));
				//strcpy(szStr,strIIT.szIssuerLabel);
				 if(strcmp(strIIT.szIssuerLabel, "BANCNET") == 0) //#00232 - When card process as DEBIT SALE terminal prints BANCNET instead of MCC DEBIT
				 		strcpy(szStr,"MCC DEBIT");    
				 else
					strcpy(szStr,strIIT.szIssuerLabel);
				
				CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
				vdCTOS_PrintAccumeByHostAndCard (inReportType, srAccumRec.stBankTotal[inTranCardType].stCardTotal[i]);
				fPrintTotal=TRUE;
			}
			//after print issuer total, then print host toal
			if(fPrintTotal == TRUE)
			{
				memset(szStr, ' ', d_LINE_SIZE);
				memset (baTemp, 0x00, sizeof(baTemp));
				strcpy(szStr,"GRAND TOTAL");
				CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
				vdCTOS_PrintAccumeByHostAndCard (inReportType, srAccumRec.stBankTotal[inTranCardType].stHOSTTotal); 
			}
		}
		else
		{
		
			memset(szStr, ' ', d_LINE_SIZE);
			memset (baTemp, 0x00, sizeof(baTemp));
			strcpy(szStr,srTransRec.szHostLabel);
			CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
			CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
            vdCTOS_PrintAccumeByHostAndCard (inReportType, srAccumRec.stBankTotal[inTranCardType].stHOSTTotal); 
		}
	}
    
	//print space one line
	CTOS_PrinterFline(d_LINE_DOT * 2);		
	CTOS_PrinterFline(d_LINE_DOT * 2);
	CTOS_PrinterFline(d_LINE_DOT * 2);
	
	return;	
}

void vdCTOS_PrintDetailReport()
{
	unsigned char chkey;
	short shHostIndex;
	int inResult,i,inCount,inRet;
	int inTranCardType;
	int inReportType;
	int inBatchNumOfRecord;
	int *pinTransDataid;
	ACCUM_REC srAccumRec;
	char szStr[d_LINE_SIZE + 1];
    BYTE baTemp[PAPER_X_SIZE * 64];

//    CTOS_PrinterPutString("vdCTOS_PrintDetailReport");

	if( printCheckPaper()==-1)
		return;

	
	//by host and merchant
	shHostIndex = inCTOS_SelectHostSetting();
	if (shHostIndex == -1)
		return;

	strHDT.inHostIndex = shHostIndex;
	DebugAddINT("detail host Index",shHostIndex);

	if (inMultiAP_CheckMainAPStatus() == d_OK)
	{
		inRet = inCTOS_MultiAPSaveData(d_IPC_CMD_DETAIL_REPORT);
		if(d_OK != inRet)
			return ;
	}
	else
	{
		if (inMultiAP_CheckSubAPStatus() == d_OK)
		{
			inRet = inCTOS_MultiAPGetData();
			if(d_OK != inRet)
				return ;

			inRet = inCTOS_MultiAPReloadHost();
			if(d_OK != inRet)
				return ;
		}
	}

	inResult = inCTOS_CheckAndSelectMutipleMID();
	DebugAddINT("detail MITid",srTransRec.MITid);
	if(d_OK != inResult)
		return;

    inResult = inCTOS_ChkBatchEmpty();
    if(d_OK != inResult)
        return;

	inBatchNumOfRecord = inBatchNumRecord();
	
	DebugAddINT("batch record",inBatchNumOfRecord);
	if(inBatchNumOfRecord <= 0)
	{
		vdDisplayErrorMsg(1, 8, "BATCH EMPTY");
		return;
	}
	
    inCTOS_SelectFont(d_FONT_FNT_MODE,d_FONT_24x24,0," ");
    vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);

		CTOS_PrinterSetHeatLevel(4);
            vdSetPrintThreadStatus(1); //##00129

	ushCTOS_printBatchRecordHeader();
	
	pinTransDataid = (int*)malloc(inBatchNumOfRecord  * sizeof(int));
	inCount = 0;		
	inBatchByMerchandHost(inBatchNumOfRecord, srTransRec.HDTid, srTransRec.MITid, srTransRec.szBatchNo, pinTransDataid);
	for(i=0; i<inBatchNumOfRecord; i++)
	{
		inResult = inDatabase_BatchReadByTransId(&srTransRec, pinTransDataid[inCount]);
        inCount ++;
		ushCTOS_printBatchRecordFooter();	
	}

    CTOS_PrinterFline(d_LINE_DOT * 1);
	
    memset(&srAccumRec, 0x00, sizeof(ACCUM_REC));
    if((inResult = inCTOS_ReadAccumTotal(&srAccumRec)) == ST_ERROR)
    {
        vdMyEZLib_LogPrintf("[vdUpdateAmountTotal]---Read Total Rec. error");
        return;    
    }

    for(inTranCardType = 0; inTranCardType < 2 ;inTranCardType ++)
    {
        if((srAccumRec.stBankTotal[inTranCardType].stHOSTTotal.usSaleCount == 0)
        && (srAccumRec.stBankTotal[inTranCardType].stHOSTTotal.usOffSaleCount == 0)
	&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usRedeemCount == 0)	
	&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usRegularCount== 0)					
	&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usReduceCount== 0)						
	&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usZeroCount== 0)				        
	&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usBNPLCount== 0)		
	&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].us2GOCount== 0)			
	&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usCashCount == 0)      
	&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usCompCount == 0)		
	&&(srAccumRec.stBankTotal[inTranCardType].stHOSTTotal.usRegularCount== 0)					
	&&(srAccumRec.stBankTotal[inTranCardType].stHOSTTotal.usReduceCount== 0)						
	&&(srAccumRec.stBankTotal[inTranCardType].stHOSTTotal.usZeroCount== 0)
        && (srAccumRec.stBankTotal[inTranCardType].stHOSTTotal.usRefundCount == 0)
        && (srAccumRec.stBankTotal[inTranCardType].stHOSTTotal.usVoidSaleCount == 0)
	&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidCashCount == 0)
	&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidCompCount == 0)
	&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidBNPLCount == 0)
	&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoid2GOCount == 0)
	&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidRefundCount == 0))
            continue;	
		
        memset(szStr, ' ', d_LINE_SIZE);
        memset (baTemp, 0x00, sizeof(baTemp));
        strcpy(szStr,"GRAND TOTAL");
        CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
        CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
        inReportType = PRINT_CARD_TOTAL;
        vdCTOS_PrintAccumeByHostAndCard (inReportType, srAccumRec.stBankTotal[inTranCardType].stHOSTTotal); 
    }

    CTOS_PrinterFline(d_LINE_DOT * 6);

	
	return;	
}




int inCTOS_rePrintLastReceipt(void)
{
	int   inResult;
	BYTE  szInvNoAsc[6+1];
	BYTE  szInvNoBcd[3];	
    BOOL   needSecond = TRUE;	
    BYTE   key;


//    	CTOS_PrinterPutString("inCTOS_rePrintLastReceipt");
	
	CTOS_PrinterSetHeatLevel(4);
	if( printCheckPaper()==-1)
		return d_NO;
	
	memcpy(srTransRec.szInvoiceNo,strTCT.szLastInvoiceNo,INVOICE_BCD_SIZE);
	DebugAddHEX("last invoice", strTCT.szLastInvoiceNo,3 );

	if (inMultiAP_CheckMainAPStatus() == d_OK)
	{
		inResult = inCTOS_MultiAPBatchSearch(d_IPC_CMD_REPRINT_LAST);
		if(d_OK != inResult)
			return inResult;
	}
	else
	{
		if (inMultiAP_CheckSubAPStatus() == d_OK)
		{
			inResult = inCTOS_MultiAPGetVoid();
			if(d_OK != inResult)
				return inResult;
		}		
		inResult = inCTOS_BatchSearch();
		if(d_OK != inResult)
			return inResult;
	}

    inIITRead(srTransRec.IITid);
    inCDTRead(srTransRec.CDTid);
	inHDTRead(srTransRec.HDTid);
	
	inResult = ushCTOS_printAll(d_FIRST_PAGE);
	if(inResult == d_OK )
	{
		if(strTCT.fPrintMerchCopy == TRUE)
	{

		CTOS_TimeOutSet(TIMER_ID_1, UI_TIMEOUT);  
		vduiDisplayStringCenter(7,"MERCHANT COPY");
		vduiDisplayStringCenter(8,"NO[X] YES[OK]");

		while(1)
		{ 
			vduiWarningSound();
			
			CTOS_KBDHit(&key);
			if(key == d_KBD_ENTER)
			{
				break;
			}
			else if((key == d_KBD_CANCEL))
			{
				needSecond = FALSE;
				break;
			}
			if(CTOS_TimeOutCheck(TIMER_ID_1) == d_YES)
			{
				break;
			}		
		}
		
		if(needSecond)
		{
			inResult=ushCTOS_printAll(d_SECOND_PAGE);
		}
		}
	}

	if(strTCT.fPrintBankCopy == TRUE)
	{
		CTOS_TimeOutSet(TIMER_ID_1, UI_TIMEOUT);
		clearLine(7);
		clearLine(8);		
		CTOS_LCDTPrintXY(1, 7, "BANK COPY");
		CTOS_LCDTPrintXY(1, 8, "NO[X] YES[OK]");
        needSecond = TRUE;

		while(1)
		{ 
			vduiWarningSound();
			
			CTOS_KBDHit(&key);
			if(key == d_KBD_ENTER)
			{
				break;
			}
			else if((key == d_KBD_CANCEL))
			{
				needSecond = FALSE;
				break;
			}
			if(CTOS_TimeOutCheck(TIMER_ID_1) == d_YES)
			{
				break;
			}		
		}
		
		if(needSecond)
		{
			ushCTOS_printAll(d_THIRD_PAGE);
		}
	}

	return d_OK;
}

USHORT ushCTOS_printReceipt(void)
{
    USHORT result;
    BYTE   key;
    BOOL   needSecond = TRUE;



    if( printCheckPaper()==-1)
    	return -1;

	vdDisplayAnimateBmp(0,0, "Printer1(320240).bmp", "Printer2(320240).bmp", "Printer3(320240).bmp", NULL, NULL);

    
    result = ushCTOS_printAll(d_FIRST_PAGE);
	CTOS_KBDBufFlush();//cleare key buffer
	
    if(result == d_OK)
    {
	if(strTCT.fPrintMerchCopy == TRUE)
    {
    
        CTOS_TimeOutSet(TIMER_ID_1, UI_TIMEOUT);  
		vduiDisplayStringCenter(7,"MERCHANT COPY");
		vduiDisplayStringCenter(8,"NO[X] YES[OK]");

        while(1)
        { 
			vduiWarningSound();
			
            CTOS_KBDHit(&key);
            if(key == d_KBD_ENTER)
            {
                break;
            }
            else if((key == d_KBD_CANCEL))
            {
		clearLine(7);            //#00049 - Unable to key in on idle mode
                needSecond = FALSE;
                break;
            }
            if(CTOS_TimeOutCheck(TIMER_ID_1) == d_YES)
            {
                break;
            }		
        }

		clearLine(8);
		
        if(needSecond)
        {
            result=ushCTOS_printAll(d_SECOND_PAGE);
        }
    	}
    }

	if(strTCT.fPrintBankCopy == TRUE)
    {
        CTOS_TimeOutSet(TIMER_ID_1, UI_TIMEOUT); 	
		clearLine(7);
		clearLine(8);
		CTOS_LCDTPrintXY(1, 7, "BANK COPY");
		CTOS_LCDTPrintXY(1, 8, "NO[X] YES[OK]");
        needSecond = TRUE;

        while(1)
        { 
			vduiWarningSound();
			
            CTOS_KBDHit(&key);
            if(key == d_KBD_ENTER)
            {
                break;
            }
            else if((key == d_KBD_CANCEL))
            {
		clearLine(7);            //#00049 - Unable to key in on idle mode
                needSecond = FALSE;
                break;
            }
            if(CTOS_TimeOutCheck(TIMER_ID_1) == d_YES)
            {
                break;
            }		
        }

		clearLine(8);
		
        if(needSecond)
        {
            return (ushCTOS_printAll(d_THIRD_PAGE));
        }
    }

	
    return (d_OK);
}



USHORT ushCTOS_printErrorReceipt(void)
{
    USHORT result;
    BYTE   key;
    BOOL   needSecond = TRUE;
	
	char szStr[d_LINE_SIZE + 1];
   char szTemp[d_LINE_SIZE + 1];
   char szTemp1[d_LINE_SIZE + 1];
   char szTemp3[d_LINE_SIZE + 1];
   char szTemp4[d_LINE_SIZE + 1];
   char szTemp5[d_LINE_SIZE + 1];
   char szFormatPAN[strlen(srTransRec.szPAN) + 7];//to account for space as in PAN format and to include additional PAN no. 7 has been added -Meena 08/01/2012
   int inFmtPANSize;
   BYTE baTemp[PAPER_X_SIZE * 64];
   CTOS_FONT_ATTRIB stFONT_ATTRIB;
   int num,i,inResult;
   unsigned char tucPrint [24*4+1];    
   BYTE   EMVtagVal[64];
   USHORT EMVtagLen; 
   short spacestring;

    
    if( printCheckPaper()==-1)
    	return -1;

	memcpy(strTCT.szLastInvoiceNo,srTransRec.szInvoiceNo,INVOICE_BCD_SIZE);
	
	if((inResult = inTCTSave(1)) != ST_SUCCESS)
    {
		vdDisplayErrorMsg(1, 8, "Update TCT fail");
    }
	
	DebugAddHEX("LastInvoiceNum", strTCT.szLastInvoiceNo,3);

	inCTOS_SelectFont(d_FONT_FNT_MODE,d_FONT_24x24,0," ");
    vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);
    
    CTOS_PrinterSetHeatLevel(4);  
	DebugAddSTR("ushCTOS_printAll","print...",20);
		

	ushCTOS_PrintHeader(d_FIRST_PAGE);

	memset(szTemp1, ' ', d_LINE_SIZE);
	sprintf(szTemp1,"%s",srTransRec.szHostLabel);
	vdPrintCenter(szTemp1);

		// - print adjustment 07132015
		szGetTransTitle(srTransRec.byTransType, szStr);     
		inPrint(szStr);   
		// - print adjustment 07132015
	
	printDateTime();

    printTIDMID(); 
	
	printBatchInvoiceNO();
	
	//szGetTransTitle(srTransRec.byTransType, szStr);     
	//	vdPrintTitleCenter(szStr);    
    if(srTransRec.byTransType == SETTLE)
    {
        DebugAddSTR("settle","print...",20);
    }
    else
    {
        //vdSetGolbFontAttrib(d_FONT_16x16, DOUBLE_SIZE, DOUBLE_SIZE, 0, 0);
    vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
        
    	memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
    	EMVtagLen = 0;
    	memset(szStr, ' ', d_LINE_SIZE);
    	vdMyEZLib_LogPrintf("CDT index: %d",srTransRec.CDTid);

    	//sprintf(szStr, "%s", srTransRec.szCardLable);
		 if(strcmp(srTransRec.szCardLable, "BANCNET") == 0) //#00232 - When card process as DEBIT SALE terminal prints BANCNET instead of MCC DEBIT
		 		strcpy(szStr,"MCC DEBIT");    
		 else
				sprintf(szStr, "%s", srTransRec.szCardLable);
    	
    	vdMyEZLib_LogPrintf("Card label: %s",srTransRec.szCardLable);
    	
    	memset (baTemp, 0x00, sizeof(baTemp));
    	CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
    	CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 

    	cardMasking(srTransRec.szPAN, PRINT_CARD_MASKING_1);
    	strcpy(szTemp4, srTransRec.szPAN);
    	memset (baTemp, 0x00, sizeof(baTemp));
    	CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szTemp4, &stgFONT_ATTRIB);
    	CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);		

        vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);
        
    	//Exp date and Entry mode
    	memset(szStr, ' ', d_LINE_SIZE);
    	memset(szTemp, 0, sizeof(szTemp));
    	memset(szTemp1, 0, sizeof(szTemp1));
    	memset(szTemp4, 0, sizeof(szTemp4));
    	memset(szTemp5, 0, sizeof(szTemp5));
    	wub_hex_2_str(srTransRec.szExpireDate, szTemp,EXPIRY_DATE_BCD_SIZE);
    	DebugAddSTR("EXP",szTemp,12);  
    	
    	for (i =0; i<4;i++)
    		szTemp[i] = '*';
    	memcpy(szTemp4,&szTemp[0],2);
    	memcpy(szTemp5,&szTemp[2],2);

    	if(srTransRec.byEntryMode==CARD_ENTRY_ICC)
    		memcpy(szTemp1,"ICC",4);
    	else if(srTransRec.byEntryMode==CARD_ENTRY_MANUAL)
    		memcpy(szTemp1,"Manual",6);
    	else if(srTransRec.byEntryMode==CARD_ENTRY_MSR)
    		memcpy(szTemp1,"MSR",3);
    	else if(srTransRec.byEntryMode==CARD_ENTRY_FALLBACK)
    		memcpy(szTemp1,"Fallback",8);
    	
    	memset (baTemp, 0x00, sizeof(baTemp));
    	sprintf(szTemp,"%s%s/%s          %s%s","EXP: ",szTemp4,szTemp5,"ENT:",szTemp1);
    	
    	DebugAddSTR("ENT:",baTemp,12);  
    	CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szTemp, &stgFONT_ATTRIB);
    	CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

    		
     	memset (baTemp, 0x00, sizeof(baTemp));
    	stFONT_ATTRIB.FontSize = 0x1010;
        stFONT_ATTRIB.X_Zoom = DOUBLE_SIZE;       // The width magnifies X_Zoom diameters
        stFONT_ATTRIB.Y_Zoom = DOUBLE_SIZE;       // The height magnifies Y_Zoom diameters

        stFONT_ATTRIB.X_Space = 0;      // The width of the space between the font with next font

    }

	memset(szStr, ' ', d_LINE_SIZE);
	memset(szTemp, ' ', d_LINE_SIZE);
	memset(szTemp1, ' ', d_LINE_SIZE);
	sprintf(szStr, "%s", "TRANS NOT SUC.");
	
	memset (baTemp, 0x00, sizeof(baTemp));
	CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stFONT_ATTRIB);
	CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 

	memset(szStr, ' ', d_LINE_SIZE);
	memset(szTemp, ' ', d_LINE_SIZE);
	memset(szTemp1, ' ', d_LINE_SIZE);
	
	sprintf(szStr, "%s", "PLS TRY AGAIN");
	
	memset (baTemp, 0x00, sizeof(baTemp));
	CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stFONT_ATTRIB);
	CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 

	CTOS_PrinterFline(d_LINE_DOT * 6); 
	
	//inSetTextMode();
    return (d_OK);
}


int inCTOS_REPRINT_ANY()
{
    char szErrMsg[30+1];
    int   inResult;
	
	fRePrintFlag = TRUE;
    vdCTOS_SetTransType(REPRINT_ANY);
	inResult = inCTOS_rePrintReceipt();

    memset(szErrMsg,0x00,sizeof(szErrMsg));
    if (inGetErrorMessage(szErrMsg) > 0)
    {
        vdDisplayErrorMsg(1, 8, szErrMsg);
        vdSetErrorMessage("");
    }
    
    memset( &srTransRec, 0x00, sizeof(TRANS_DATA_TABLE));
    CTOS_KBDBufFlush();
	fRePrintFlag = FALSE;
	return inResult;
}

int inCTOS_REPRINT_LAST()
{
    char szErrMsg[30+1];
	int   inResult;
    
	fRePrintFlag = TRUE;
	inResult = inCTOS_rePrintLastReceipt();	

    memset(szErrMsg,0x00,sizeof(szErrMsg));
    if (inGetErrorMessage(szErrMsg) > 0)
    {
        vdDisplayErrorMsg(1, 8, szErrMsg);
        vdSetErrorMessage("");
    }
    
    memset( &srTransRec, 0x00, sizeof(TRANS_DATA_TABLE));
    CTOS_KBDBufFlush();
	fRePrintFlag = FALSE;
	
	return inResult;
}

int inCTOS_PRINTF_SUMMARY()
{
    char szErrMsg[30+1];
    
	vdCTOS_PrintSummaryReport();	

    memset(szErrMsg,0x00,sizeof(szErrMsg));
    if (inGetErrorMessage(szErrMsg) > 0)
    {
        vdDisplayErrorMsg(1, 8, szErrMsg);
        vdSetErrorMessage("");
    }
    
    memset( &srTransRec, 0x00, sizeof(TRANS_DATA_TABLE));
    CTOS_KBDBufFlush();
    
	return d_OK;
	
}

int inCTOS_PRINTF_DETAIL()
{
    char szErrMsg[30+1];
    
	vdCTOS_PrintDetailReport();	

    memset(szErrMsg,0x00,sizeof(szErrMsg));
    if (inGetErrorMessage(szErrMsg) > 0)
    {
        vdDisplayErrorMsg(1, 8, szErrMsg);
        vdSetErrorMessage("");
    }
    
    memset( &srTransRec, 0x00, sizeof(TRANS_DATA_TABLE));
    CTOS_KBDBufFlush();
    
	return d_OK;
	
}

int inCTOS_REPRINTF_LAST_SETTLEMENT()
{
    char szErrMsg[30+1];
    
	ushCTOS_ReprintLastSettleReport();
    
    memset(szErrMsg,0x00,sizeof(szErrMsg));
    if (inGetErrorMessage(szErrMsg) > 0)
    {
		CTOS_LCDTClearDisplay();
        vdDisplayErrorMsg(1, 8, szErrMsg);
        vdSetErrorMessage("");
    }
    memset( &srTransRec, 0x00, sizeof(TRANS_DATA_TABLE));
    CTOS_KBDBufFlush();
    
    return d_OK;
}

void vdCTOS_PrintAccumeByHostAndCard (int inReportType, STRUCT_TOTAL Totals)
{
    USHORT usSaleCount=Totals.usSaleCount-Totals.usOffSaleCount;
    ULONG ulSaleTotalAmount=Totals.ulSaleTotalAmount-Totals.ulOffSaleTotalAmount;
    USHORT usRefundCount=Totals.usRefundCount;
    ULONG  ulRefundTotalAmount=Totals.ulRefundTotalAmount;   
    USHORT usVoidSaleCount=Totals.usVoidSaleCount;// + Totals.usRefundCount; #00189
    ULONG  ulVoidSaleTotalAmount=Totals.ulVoidSaleTotalAmount;// + Totals.ulRefundTotalAmount; #00189
    USHORT usOffSaleCount=Totals.usOffSaleCount;
    ULONG  ulOffSaleTotalAmount=Totals.ulOffSaleTotalAmount;
    USHORT usTipCount=Totals.usTipCount;
    ULONG  ulTipAmount=Totals.ulTipTotalAmount;

    USHORT usVoidRefundCount=Totals.usVoidRefundCount;
    ULONG  ulVoidRefundTotalAmount=Totals.ulVoidRefundTotalAmount;

	//RTR
    USHORT usRedeemCount=Totals.usRedeemCount;
    ULONG  ulRedeemTotalAmount=Totals.ulRedeemTotalAmount;
    USHORT usVoidRedeemCount=Totals.usVoidRedeemCount;
    ULONG  ulVoidRedeemTotalAmount=Totals.ulVoidRedeemTotalAmount;

	// Regular
    USHORT usRegularCount=Totals.usRegularCount;
    ULONG  ulRegularTotalAmount=Totals.ulRegularTotalAmount;
    USHORT usVoidRegularCount=Totals.usVoidRegularCount;
    ULONG  ulVoidRegularTotalAmount=Totals.ulVoidRegularTotalAmount;


	// Reduce
    USHORT usReduceCount=Totals.usReduceCount;
    ULONG  ulReduceTotalAmount=Totals.ulReduceTotalAmount;
    USHORT usVoidReduceCount=Totals.usVoidReduceCount;
    ULONG  ulVoidReduceTotalAmount=Totals.ulVoidReduceTotalAmount;

	// Zero
    USHORT usZeroCount=Totals.usZeroCount;
    ULONG  ulZeroTotalAmount=Totals.ulZeroTotalAmount;
    USHORT usVoidZeroCount=Totals.usVoidZeroCount;
    ULONG  ulVoidZeroTotalAmount=Totals.ulVoidZeroTotalAmount;

	// bnpl
    USHORT usBNPLCount=Totals.usBNPLCount;
    ULONG  ulBNPLTotalAmount=Totals.ulBNPLTotalAmount;
    USHORT usVoidBNPLCount=Totals.usVoidBNPLCount;
    ULONG  ulVoidBNPLTotalAmount=Totals.ulVoidBNPLTotalAmount;

	//cash2Go
    USHORT us2GOCount=Totals.us2GOCount;
    ULONG  ul2GOTotalAmount=Totals.ul2GOTotalAmount;
    USHORT usVoid2GOCount=Totals.usVoid2GOCount;
    ULONG  ulVoid2GOTotalAmount=Totals.ulVoid2GOTotalAmount;

//Cash
    USHORT usCashCount=Totals.usCashCount;
    ULONG  ulCashTotalAmount=Totals.ulCashTotalAmount;
    USHORT usVoidCashCount=Totals.usVoidCashCount;
    ULONG  ulVoidCashTotalAmount=Totals.ulVoidCashTotalAmount;

// sale completion
    USHORT usCompCount=Totals.usCompCount;
    ULONG  ulCompTotalAmount=Totals.ulCompTotalAmount;
    USHORT usVoidCompCount=Totals.usVoidCompCount;
    ULONG  ulVoidCompTotalAmount=Totals.ulVoidCompTotalAmount;

		char szStr[d_LINE_SIZE + 1];
		char szTemp[d_LINE_SIZE + 1];
		char szFormattedAmount[d_LINE_SIZE + 1];
		USHORT usTotalCount;
		ULONG  ulTotalAmount;
		BYTE baTemp[PAPER_X_SIZE * 64];
		
		CTOS_PrinterSetHeatLevel(4);  
		memset (baTemp, 0x00, sizeof(baTemp));		

//    CTOS_PrinterPutString("vdCTOS_PrintAccumeByHostAndCard");

// fix for Wrong implementation of USD Currency
//USD currency prompts upon voiding & settlement
        inTCTRead(1);	
	if(strTCT.fRegUSD == 1) 
		inCSTRead(2);
	else
		inCSTRead(1);
		
		//types
		memset(szStr, 0x00, d_LINE_SIZE);
		strcpy(szStr,"TYPES           COUNT     CUR              AMT");
		inPrint(szStr);

		//sale
		memset(szStr, ' ', d_LINE_SIZE);
		memset(szTemp, 0x00, d_LINE_SIZE);
		memset(szFormattedAmount, 0x00, d_LINE_SIZE);
		sprintf(szTemp,"%ld", ulSaleTotalAmount);
		vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
		sprintf(szStr,"SALES           %3d       %s",usSaleCount, strCST.szCurSymbol);
		inPrintLeftRight(szStr, szFormattedAmount, 46);

		if(usRedeemCount > 0)	
		{	
			//RTR
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulRedeemTotalAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			sprintf(szStr,"RTR REDEEM      %3d       %s",usRedeemCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}

		if(usRegularCount > 0)
		{
			//Regular sale
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulRegularTotalAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			sprintf(szStr,"INST REGULAR    %3d       %s",usRegularCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}

		if(usReduceCount > 0)
		{
			//Reduce sale
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulReduceTotalAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			sprintf(szStr,"INST REDUCE     %3d       %s",usReduceCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}



		if(usZeroCount > 0)
		{
			//Zero sale
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulZeroTotalAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			sprintf(szStr,"INST ZERO       %3d       %s",usZeroCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}

		if(usBNPLCount > 0)
		{
			//Zero sale
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulBNPLTotalAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			sprintf(szStr,"INST BNPL       %3d       %s",usBNPLCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}

		if(us2GOCount > 0)
		{
			//Cash2Go
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ul2GOTotalAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			sprintf(szStr,"INST C2GO       %3d       %s",us2GOCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}
		

		if(usCashCount > 0)	
		{	
			//CASH ADV
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulCashTotalAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			sprintf(szStr,"CASH ADV        %3d       %s",usCashCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}

		if(usCompCount > 0)	
		{	
			//SALE COMP
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulCompTotalAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			sprintf(szStr,"SALE COMP       %3d       %s",usCompCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}
		
		//void
		memset(szStr, ' ', d_LINE_SIZE);
		memset(szTemp, 0x00, d_LINE_SIZE);
		memset(szFormattedAmount, 0x00, d_LINE_SIZE);
		sprintf(szTemp,"%ld", ulVoidSaleTotalAmount);
		szFormattedAmount[0]='-'; // #00068 - *Void  total should have negative sign
		vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,&szFormattedAmount[1]);
		//vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
		sprintf(szStr,"VOID            %3d       %s", usVoidSaleCount,strCST.szCurSymbol);
		inPrintLeftRight(szStr, szFormattedAmount, 46);
		
		if(usVoidRedeemCount > 0)
		{
			//VOID RTR
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulVoidRedeemTotalAmount);
			szFormattedAmount[0]='-'; // #00068 - *Void  total should have negative sign
			//vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,&szFormattedAmount[1]);
			sprintf(szStr,"RTR VOID        %3d       %s",usVoidRedeemCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}


		if(usVoidRegularCount > 0)
		{
			//VOID Regular
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulVoidRegularTotalAmount);
			szFormattedAmount[0]='-'; // #00068 - *Void  total should have negative sign			
			//vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,&szFormattedAmount[1]);
			sprintf(szStr,"VOID INST REG   %3d       %s",usVoidRegularCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}

		if(usVoidReduceCount > 0)
		{
			//VOID Reduce
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulVoidReduceTotalAmount);
			szFormattedAmount[0]='-'; // #00068 - *Void  total should have negative sign						
			//vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,&szFormattedAmount[1]);			
			sprintf(szStr,"VOID INST RED   %3d       %s",usVoidReduceCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}


		if(usVoidZeroCount > 0)
		{
			//VOID Zero
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulVoidZeroTotalAmount);
			szFormattedAmount[0]='-'; // #00068 - *Void  total should have negative sign									
			//vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,&szFormattedAmount[1]);
			sprintf(szStr,"VOID INST ZERO  %3d       %s",usVoidZeroCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}

		if(usVoidBNPLCount > 0)
		{
			//VOID BNPL
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulVoidBNPLTotalAmount);
			szFormattedAmount[0]='-'; // #00068 - *Void  total should have negative sign									
			//vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,&szFormattedAmount[1]);
			sprintf(szStr,"VOID INST BNPL  %3d       %s",usVoidBNPLCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}

		if(usVoid2GOCount > 0)
		{
			//VOID 2GO
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulVoid2GOTotalAmount);
			szFormattedAmount[0]='-'; // #00068 - *Void  total should have negative sign									
			//vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,&szFormattedAmount[1]);
			sprintf(szStr,"VOID CASH2GO    %3d       %s",usVoid2GOCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}
		

		if(usVoidCashCount > 0)
		{
			//VOID CASH ADV
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulVoidCashTotalAmount);
			szFormattedAmount[0]='-'; // #00068 - *Void  total should have negative sign												
			//vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,&szFormattedAmount[1]);			
			sprintf(szStr,"VOID CASH ADV   %3d       %s",usVoidCashCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}

		if(usVoidCompCount > 0)
		{
			//VOID SALE COMP
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulVoidCompTotalAmount);
			szFormattedAmount[0]='-'; // #00068 - *Void  total should have negative sign															
			//vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,&szFormattedAmount[1]);			
			sprintf(szStr,"VOID SALE COMP  %3d       %s",usVoidCompCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}

		if(usVoidRefundCount > 0)
		{
			//VOID REFUND
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulVoidRefundTotalAmount);
			szFormattedAmount[0]='-'; // #00068 - *Void  total should have negative sign															
			//vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,&szFormattedAmount[1]);			
			sprintf(szStr,"VOID REFUND     %3d       %s",usVoidRefundCount, strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		}

		//#00210 - Terminal prints the TIP/OFFLINE AND  REFUND on settlement/summary and detailed report/ on shopcard host - for testing
		//if(inInstallmentGroup == 2 && strCDT.inInstGroup == 4)
		   	//CTOS_PrinterPutString("inInstallmentGroup");
		//else
		//{	
			//refund
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulRefundTotalAmount);
			szFormattedAmount[0]='-'; // #00068 - *Refund  total should have negative sign
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,&szFormattedAmount[1]);
			//vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			sprintf(szStr,"REFUNDS         %3d       %s", usRefundCount,strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);

			//tips sale
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulTipAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			sprintf(szStr,"TIPS                      %s", strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
			
			//offline sale
			memset(szStr, ' ', d_LINE_SIZE);
			memset(szTemp, 0x00, d_LINE_SIZE);
			memset(szFormattedAmount, 0x00, d_LINE_SIZE);
			sprintf(szTemp,"%ld", ulOffSaleTotalAmount);
			vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,szFormattedAmount);
			sprintf(szStr,"OFFLINE         %3d       %s", usOffSaleCount,strCST.szCurSymbol);
			inPrintLeftRight(szStr, szFormattedAmount, 46);
		//}
		
		CTOS_PrinterPutString("----------------------------------------------");
		
		usTotalCount = usSaleCount + usOffSaleCount + usRefundCount + usRedeemCount + usRegularCount + usReduceCount + usZeroCount + usBNPLCount +us2GOCount+ usCashCount + usCompCount;
		//usTotalCount = usSaleCount + usOffSaleCount + usRefundCount;
		memset(szStr, ' ', d_LINE_SIZE);
		memset(szTemp, 0x00, d_LINE_SIZE);
		memset(szFormattedAmount, 0x00, d_LINE_SIZE);
		if (inReportType == PRINT_HOST_TOTAL)
		{
			if(ulRefundTotalAmount > (ulSaleTotalAmount+ulOffSaleTotalAmount+ulRedeemTotalAmount+ulRegularTotalAmount+ulReduceTotalAmount+ulZeroTotalAmount+ulBNPLTotalAmount+ul2GOTotalAmount+ulCashTotalAmount+ulCompTotalAmount))
			//if(ulRefundTotalAmount > (ulSaleTotalAmount+ulOffSaleTotalAmount))
			{
				ulTotalAmount = ulRefundTotalAmount - (ulSaleTotalAmount+ulOffSaleTotalAmount+ulRedeemTotalAmount+ulRegularTotalAmount+ulReduceTotalAmount+ulZeroTotalAmount+ulBNPLTotalAmount+ul2GOTotalAmount+ulCashTotalAmount+ulCompTotalAmount);
				//ulTotalAmount = ulRefundTotalAmount - (ulSaleTotalAmount+ulOffSaleTotalAmount);
				
				sprintf(szTemp,"%ld", ulTotalAmount);
				vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,&szFormattedAmount[1]);
                szFormattedAmount[0]='-';
			}
			else
			{
				ulTotalAmount = (ulSaleTotalAmount+ulOffSaleTotalAmount+ulRedeemTotalAmount+ulRegularTotalAmount+ulReduceTotalAmount+ulZeroTotalAmount+ulBNPLTotalAmount+ul2GOTotalAmount+ulCashTotalAmount+ulCompTotalAmount) - ulRefundTotalAmount;
				//ulTotalAmount = (ulSaleTotalAmount+ulOffSaleTotalAmount) - ulRefundTotalAmount;
				sprintf(szTemp,"%ld", ulTotalAmount);
				vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp, szFormattedAmount);
			}
		}
		else if(inReportType == PRINT_CARD_TOTAL)
		{
			if(ulRefundTotalAmount > (ulSaleTotalAmount+ulOffSaleTotalAmount+ulRedeemTotalAmount+ulRegularTotalAmount+ulReduceTotalAmount+ulZeroTotalAmount+ulBNPLTotalAmount+ul2GOTotalAmount+ulCashTotalAmount+ulCompTotalAmount))
			//if(ulRefundTotalAmount > (ulSaleTotalAmount+ulOffSaleTotalAmount))
			{
				ulTotalAmount = ulRefundTotalAmount - (ulSaleTotalAmount+ulOffSaleTotalAmount+ulRedeemTotalAmount+ulRegularTotalAmount+ulReduceTotalAmount+ulZeroTotalAmount+ulBNPLTotalAmount+ul2GOTotalAmount+ulCashTotalAmount+ulCompTotalAmount);
				//ulTotalAmount = ulRefundTotalAmount - (ulSaleTotalAmount+ulOffSaleTotalAmount);
				sprintf(szTemp,"%ld", ulTotalAmount);
				vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp,&szFormattedAmount[1]);
                szFormattedAmount[0]='-';
			}
			else
			{
				ulTotalAmount = (ulSaleTotalAmount+ulOffSaleTotalAmount+ulRedeemTotalAmount+ulRegularTotalAmount+ulReduceTotalAmount+ulZeroTotalAmount+ulBNPLTotalAmount+ul2GOTotalAmount+ulCashTotalAmount+ulCompTotalAmount) - ulRefundTotalAmount;
				//ulTotalAmount = (ulSaleTotalAmount+ulOffSaleTotalAmount) - ulRefundTotalAmount;
				sprintf(szTemp,"%ld", ulTotalAmount);
				vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTemp, szFormattedAmount);
			}	 
		}
		sprintf(szStr,"TOTALS          %3d       %s", usTotalCount,strCST.szCurSymbol);
		inPrintLeftRight(szStr, szFormattedAmount, 46);

		CTOS_PrinterFline(d_LINE_DOT * 1);
}

int inCTOS_SelectFont(int inFontMode,int inFontSize ,int inFontStyle,char * szFontName)
{
	if(inFontMode == d_FONT_TTF_MODE)
	{
		CTOS_PrinterFontSelectMode(d_FONT_TTF_MODE);	//set the printer with TTF Mode
		CTOS_PrinterTTFSelect("times.ttf", inFontStyle);
	}
	else
	{
	
		CTOS_PrinterFontSelectMode(d_FONT_FNT_MODE);	//set the printer with default Mode
		CTOS_LanguagePrinterFontSize(inFontSize, 0, TRUE);		
	}
	return d_OK;
	
}

int inCTOS_PrintSettleReport(BOOL fManualSettle)
{
	ACCUM_REC srAccumRec;
	unsigned char chkey;
	short shHostIndex;
	int inResult;
	int inTranCardType;
	int inReportType;
	int i;		
	char szStr[d_LINE_SIZE + 1];
	BYTE baTemp[PAPER_X_SIZE * 64];	
    int *pinTransDataid;
	int inBatchNumOfRecord;
	int inCount;

	
	if( printCheckPaper()==-1)
		return;

	inResult = inCTOS_ChkBatchEmpty();
	if(d_OK != inResult)
	{
		return;
	}

	inCTLOS_Updatepowrfail(PFR_BATCH_SETTLEMENT_PRINT);//1204
	
	memset(&srAccumRec, 0x00, sizeof(ACCUM_REC));
    if((inResult = inCTOS_ReadAccumTotal(&srAccumRec)) == ST_ERROR)
    {
        vdMyEZLib_LogPrintf("[vdUpdateAmountTotal]---Read Total Rec. error");
		vdSetErrorMessage("Read Accum Error");
        return ST_ERROR;    
    }
    
	inCTOS_SelectFont(d_FONT_FNT_MODE,d_FONT_24x24,0," ");
	vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);

	CTOS_PrinterSetHeatLevel(4);

	vdSetPrintThreadStatus(1);
		
	ushCTOS_PrintHeader(0);	

	vdPrintTitleCenter("SETTLEMENT REPORT");

	CTOS_PrinterFline(d_LINE_DOT * 1);

	vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);

    printHostLabel();
    
	printTIDMID();

	printDateTime();

	printBatchNO();    

    // additional - mfl
#if 1    
    CTOS_PrinterFline(d_LINE_DOT * 1);
    vdPrintCenter("*** SUMMARY REPORT ***");
    CTOS_PrinterFline(d_LINE_DOT * 1);
#endif

	for(inTranCardType = 0; inTranCardType < 2 ;inTranCardType ++)
	{
		BOOL fPrintTotal=FALSE;
		inReportType = PRINT_CARD_TOTAL;
		
		if(inReportType == PRINT_CARD_TOTAL)
		{
			for(i= 0; i <20; i ++ )
			{
				vdDebug_LogPrintf("--Count[%d]", i);							
				if((srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usSaleCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usRedeemCount == 0)	
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usCashCount == 0)				
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usCompCount == 0)								
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usRegularCount== 0)		
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usReduceCount== 0)						
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usZeroCount== 0)					
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usBNPLCount== 0)	
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].us2GOCount== 0)					
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usOffSaleCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usRefundCount == 0)				
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidRegularCount== 0)									
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidReduceCount== 0)									
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidZeroCount== 0)													
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidBNPLCount== 0)																	
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoid2GOCount== 0)																					
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidSaleCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidRedeemCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidCashCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidCompCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidRefundCount== 0))
					continue;
				
				vdDebug_LogPrintf("Count[%d]", i); 
				inIITRead(i);
				memset(szStr, ' ', d_LINE_SIZE);
				memset (baTemp, 0x00, sizeof(baTemp));
				//strcpy(szStr,strIIT.szIssuerLabel);
				 if(strcmp(strIIT.szIssuerLabel, "BANCNET") == 0) //#00232 - When card process as DEBIT SALE terminal prints BANCNET instead of MCC DEBIT
				 		strcpy(szStr,"MCC DEBIT");    
				 else
					strcpy(szStr,strIIT.szIssuerLabel);
				
				CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
                		vdCTOS_PrintAccumeByHostAndCard (inReportType, srAccumRec.stBankTotal[inTranCardType].stCardTotal[i]);
				fPrintTotal=TRUE;
			}
			//after print issuer total, then print host toal
			if(fPrintTotal == TRUE)
			{
				memset(szStr, ' ', d_LINE_SIZE);
				memset (baTemp, 0x00, sizeof(baTemp));
				strcpy(szStr,"GRAND TOTAL");
				CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
                		vdCTOS_PrintAccumeByHostAndCard (inReportType, srAccumRec.stBankTotal[inTranCardType].stHOSTTotal); 
			}
		}
		else
		{
		
			memset(szStr, ' ', d_LINE_SIZE);
			memset (baTemp, 0x00, sizeof(baTemp));
			strcpy(szStr,srTransRec.szHostLabel);
			CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
			CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
            		vdCTOS_PrintAccumeByHostAndCard (inReportType, srAccumRec.stBankTotal[inTranCardType].stHOSTTotal); 
		}
	}

	
// fix for Wrong format of Settlement receipt
//Detailed report is printed first. should be summary 1st the detail report
#if 1
    CTOS_PrinterFline(d_LINE_DOT * 1);
    vdPrintCenter("*** DETAIL REPORT ***");
    CTOS_PrinterFline(d_LINE_DOT * 1);
    
	vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);

#if 1
// additional - mfl
    inPrint("CARD NAME           CARD NUMBER");
    inPrint("EXP DATE            TRACE NO.");
    inPrint("TRANSACTION         AMOUNT");
    inPrint("APPR. CODE          ENTRY MODE");
	
    printDividingLine(DIVIDING_LINE_DOUBLE);
#endif

	inBatchNumOfRecord = inBatchNumRecord();


	pinTransDataid = (int*)malloc(inBatchNumOfRecord  * sizeof(int));
	inCount = 0;		
	inBatchByMerchandHost(inBatchNumOfRecord, srTransRec.HDTid, srTransRec.MITid, srTransRec.szBatchNo, pinTransDataid);
	for(i=0; i<inBatchNumOfRecord; i++)
	{
		inResult = inDatabase_BatchReadByTransId(&srTransRec, pinTransDataid[inCount]);
        inCount ++;
		ushCTOS_printBatchRecordFooter();	
	}

#endif

	//#00014 - No "Settlement confirmed" upon printing Last settlement Report
    if(fManualSettle == TRUE)
    {
        vdPrintTitleCenter("DELETED BATCH FOR");
		vdPrintTitleCenter("MANUAL POSTING");
    }
    else		
    	vdPrintTitleCenter("SETTLEMENT CONFIRMED");
    
	//print space one line
	CTOS_PrinterFline(d_LINE_DOT * 8);		
	
	return d_OK;	
}

USHORT ushCTOS_printBatchRecordHeader(void)
{
	USHORT result;
	BYTE baTemp[PAPER_X_SIZE * 64];

    ushCTOS_PrintHeader(0);	
    
    vdPrintTitleCenter("DETAIL REPORT");
	CTOS_PrinterFline(d_LINE_DOT * 1);

	vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
    printHostLabel();
    
	printTIDMID();
	
	vdCTOS_SetDateTime();
	 
	printDateTime();
    
	printBatchNO();
    
    CTOS_PrinterFline(d_LINE_DOT * 1);
    inPrint("CARD NAME           CARD NUMBER");
    inPrint("EXP DATE            TRACE NO.");
    inPrint("TRANSACTION         AMOUNT");
    inPrint("APPR. CODE          ENTRY MODE");
	
	printDividingLine(DIVIDING_LINE_DOUBLE);
	return d_OK;
}


USHORT ushCTOS_printBatchRecordFooter(void)
{
	BYTE baTemp[PAPER_X_SIZE * 64];		
	char szStr[d_LINE_SIZE + 1];
	char szPrintBuf[d_LINE_SIZE + 1];
	char szTempBuf1[d_LINE_SIZE + 1];
	char szTempBuf2[d_LINE_SIZE + 1];
	char szTempBuf3[d_LINE_SIZE + 1];

	BYTE szBaseAmount[20];
	BYTE szTipAmount[20];
	BYTE szTotalAmount[20];

	int i;

//    	CTOS_PrinterPutString("ushCTOS_printBatchRecordFooter");

	DebugAddSTR("ushCTOS_printBatchRecordFooter", srTransRec.szPAN, 10);
	memset(szTempBuf1,0,sizeof(szTempBuf1));
	memset(szTempBuf2, 0, sizeof(szTempBuf2));
	strcpy(szTempBuf1,srTransRec.szPAN);    
	inIITRead(srTransRec.IITid);

	 if(strcmp(strIIT.szIssuerLabel, "BANCNET") == 0) //#00232 - When card process as DEBIT SALE terminal prints BANCNET instead of MCC DEBIT
	 		strcpy(szTempBuf2,"MCC DEBIT");    
	 else
		strcpy(szTempBuf2,strIIT.szIssuerLabel);
	 
	if(strHDT.fMaskDetail == TRUE)
	cardMasking(szTempBuf1, PRINT_CARD_MASKING_3);

	memset (szPrintBuf, 0x00, sizeof(szPrintBuf));
	strcpy(szPrintBuf, szTempBuf2);
	memset(&szPrintBuf[strlen(szPrintBuf)], 0x20, 20-strlen(szTempBuf2));
	strcat(szPrintBuf, szTempBuf1);
	inPrint(szPrintBuf);

	//Exp date and inv num
	memset(szTempBuf1, 0, sizeof(szTempBuf1));
	memset(szTempBuf2, 0, sizeof(szTempBuf2));
	memset(szTempBuf3, 0, sizeof(szTempBuf3));
	
	wub_hex_2_str(srTransRec.szExpireDate, szTempBuf1,EXPIRY_DATE_BCD_SIZE);
	DebugAddSTR("detail--EXP",szTempBuf1,12);  

	
    if(strHDT.fMaskDetail == TRUE)
    {
       for (i =0; i<4;i++)
       szTempBuf1[i] = '*';
    }
	memcpy(szTempBuf2,&szTempBuf1[0],2);
	memcpy(szTempBuf3,&szTempBuf1[2],2);

	memset(szStr, 0,sizeof(szStr));
	wub_hex_2_str(srTransRec.szInvoiceNo, szStr, INVOICE_BCD_SIZE);
		
	memset (szPrintBuf, 0x00, sizeof(szPrintBuf));
	strcpy(szPrintBuf, szTempBuf2);
	strcat(szPrintBuf, szTempBuf3);
	memset(&szPrintBuf[strlen(szPrintBuf)], 0x20, 20-strlen(szTempBuf2)-strlen(szTempBuf3));
	strcat(szPrintBuf, szStr);
	inPrint(szPrintBuf);
 
    memset(szStr, 0,sizeof(szStr));
    memset(szTempBuf1, 0,sizeof(szTempBuf1));
    memset(szTempBuf2, 0,sizeof(szTempBuf2));
	if(srTransRec.byTransType == LOY_REDEEM_5050 || srTransRec.byTransType == LOY_REDEEM_VARIABLE)
	    strcpy(szStr, "REDEEM");
	else
        szGetTransTitle(srTransRec.byTransType, szStr);
    	wub_hex_2_str(srTransRec.szTotalAmount, szTempBuf1, AMT_BCD_SIZE); // amount printout for detail report.
	vdCTOS_FormatAmount("NNN,NNN,NNn.nn", szTempBuf1, szTempBuf2);


    memset(szPrintBuf, 0x20, sizeof(szPrintBuf));
	memcpy(szPrintBuf, szStr, strlen(szStr));
	memcpy(&szPrintBuf[20], szTempBuf2, strlen(szTempBuf2));
	szPrintBuf[46]=0x00;
	inPrint(szPrintBuf);
	
	memset(szTempBuf2, 0,sizeof(szTempBuf2));
	if(srTransRec.byEntryMode==CARD_ENTRY_ICC)
		memcpy(szTempBuf2,"ICC",4);
	else if(srTransRec.byEntryMode==CARD_ENTRY_MANUAL)
		memcpy(szTempBuf2,"Manual",6);
	else if(srTransRec.byEntryMode==CARD_ENTRY_MSR)
		memcpy(szTempBuf2,"MSR",3);
	else if(srTransRec.byEntryMode==CARD_ENTRY_FALLBACK)
		memcpy(szTempBuf2,"Fallback",8);


    memset (szPrintBuf, 0x00, sizeof(szPrintBuf));
    strcpy(szPrintBuf, srTransRec.szAuthCode);
    memset(&szPrintBuf[strlen(szPrintBuf)], 0x20, 20-strlen(srTransRec.szAuthCode));
    strcat(szPrintBuf, szTempBuf2);
	inPrint(szPrintBuf);
	
	
	CTOS_PrinterFline(d_LINE_DOT * 1);

	
}

USHORT ushCTOS_GetFontInfor(void)
{
	USHORT usASCIIFontID;
	USHORT usFontSize;
	USHORT usFontStyle;

	CTOS_LanguagePrinterGetFontInfo( &usASCIIFontID, &usFontSize, &usFontStyle );   
	vdDebug_LogPrintf("usASCIIFontID[%d]usFontSize[%d]usFontStyle[%d]",usFontSize,usFontStyle );
}

USHORT ushCTOS_ReprintLastSettleReport(void)
{
	ACCUM_REC srAccumRec;
	unsigned char chkey;
	short shHostIndex;
	int inResult,inRet;
	int inTranCardType;
	int inReportType;
	int inIITNum , i;
	char szStr[d_LINE_SIZE + 1];
	BYTE baTemp[PAPER_X_SIZE * 64];
    	int *pinTransDataid;
	int inBatchNumOfRecord;
	int inCount;

//    	CTOS_PrinterPutString("ushCTOS_ReprintLastSettleReport");

	if( printCheckPaper()==-1)
		return;

		
	//by host and merchant
	shHostIndex = inCTOS_SelectHostSetting();
	if (shHostIndex == -1)
		return;
	strHDT.inHostIndex = shHostIndex;
	DebugAddINT("summary host Index",shHostIndex);
	inCSTRead(strHDT.inCurrencyIdx);

	if (inMultiAP_CheckMainAPStatus() == d_OK)
	{
		inRet = inCTOS_MultiAPSaveData(d_IPC_CMD_REPRINT_LAST_SETT);
		if(d_OK != inRet)
			return inRet;
	}
	else
	{
		if (inMultiAP_CheckSubAPStatus() == d_OK)
		{
			inRet = inCTOS_MultiAPGetData();
			if(d_OK != inRet)
				return inRet;

			inRet = inCTOS_MultiAPReloadHost();
			if(d_OK != inRet)
				return inRet;
		}
	}

	inResult = inCTOS_CheckAndSelectMutipleMID();
	DebugAddINT("summary MITid",srTransRec.MITid);
	if(d_OK != inResult)
		return;

	memset(&srAccumRec, 0x00, sizeof(ACCUM_REC));
	inResult = inCTOS_ReadBKAccumTotal(&srAccumRec,strHDT.inHostIndex,srTransRec.MITid);
	if(inResult == ST_ERROR)
	{
   //CTOS_LCDTClearDisplay(); // fix on issue #00106 Error message must not appear on Host Selection after selecting host
	
	    vdSetErrorMessage("NO RECORD FOUND");
		vdMyEZLib_LogPrintf("[vdUpdateAmountTotal]---Read Total Rec. error");
		return ST_ERROR;	
	}		 
	else if(inResult == RC_FILE_READ_OUT_NO_DATA)
	{
   //CTOS_LCDTClearDisplay(); // fix on issue #00106 Error message must not appear on Host Selection after selecting host
	
	    vdSetErrorMessage("NO RECORD FOUND");
		return;
	}	 
    strcpy(srTransRec.szTID, srAccumRec.szTID);
    strcpy(srTransRec.szMID, srAccumRec.szMID);
    memcpy(srTransRec.szYear, srAccumRec.szYear, DATE_BCD_SIZE);
    memcpy(srTransRec.szDate, srAccumRec.szDate, DATE_BCD_SIZE);
    memcpy(srTransRec.szTime, srAccumRec.szTime, TIME_BCD_SIZE);
    memcpy(srTransRec.szBatchNo, srAccumRec.szBatchNo, BATCH_NO_BCD_SIZE);

    inCTOS_SelectFont(d_FONT_FNT_MODE,d_FONT_24x24,0," ");
    vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);

	CTOS_PrinterSetHeatLevel(4);
        vdSetPrintThreadStatus(1); //##00129

	ushCTOS_PrintHeader(0);	

    vdPrintTitleCenter("LAST SETTLEMENT REPORT");
	CTOS_PrinterFline(d_LINE_DOT * 1);

    vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
    printHostLabel();
    
	printTIDMID();
    
	printDateTime();
    
	printBatchNO();

// to include detail report on reprint settlement
#if 0
    CTOS_PrinterFline(d_LINE_DOT * 1);
    vdPrintCenter("*** DETAIL REPORT ***");
    CTOS_PrinterFline(d_LINE_DOT * 1);
    
	vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);

// additional - mfl
    inPrint("CARD NAME           CARD NUMBER");
    inPrint("EXP DATE            TRACE NO.");
    inPrint("TRANSACTION         AMOUNT");
    inPrint("APPR. CODE          ENTRY MODE");
	
    printDividingLine(DIVIDING_LINE_DOUBLE);

	inBatchNumOfRecord = inBatchNumRecord();

{
	char szTemp[50+1];
	memset(szTemp,0x00,sizeof(szTemp));
	sprintf(szTemp, "inBatchNumOfRecord: [%ld]", inBatchNumOfRecord);
    	CTOS_PrinterPutString(szTemp);

}
	pinTransDataid = (int*)malloc(inBatchNumOfRecord  * sizeof(int));
	inCount = 0;		
	inBatchByMerchandHost(inBatchNumOfRecord, srTransRec.HDTid, srTransRec.MITid, srTransRec.szBatchNo, pinTransDataid);
	for(i=0; i<inBatchNumOfRecord; i++)
	{
		inResult = inDatabase_BatchReadByTransId(&srTransRec, pinTransDataid[inCount]);
        inCount ++;
		ushCTOS_printBatchRecordFooter();	
	}

    // additional - mfl
    CTOS_PrinterFline(d_LINE_DOT * 1);
    vdPrintCenter("*** SUMMARY REPORT ***");
    CTOS_PrinterFline(d_LINE_DOT * 1);
#endif


    CTOS_PrinterFline(d_LINE_DOT * 1);
	for(inTranCardType = 0; inTranCardType < 2 ;inTranCardType ++)
	{
		BOOL fPrintTotal=FALSE;
		inReportType = PRINT_CARD_TOTAL;
		
		if(inReportType == PRINT_CARD_TOTAL)
		{
			for(i= 0; i <20; i ++ )
			{
				vdDebug_LogPrintf("--Count[%d]", i);
				if((srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usSaleCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usOffSaleCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usRedeemCount == 0)	
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usCashCount == 0)					
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usCompCount == 0)									
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usRegularCount== 0)					
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usReduceCount== 0)						
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usZeroCount== 0)				
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usBNPLCount== 0)								
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].us2GOCount== 0)												
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usRefundCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidRegularCount== 0)									
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidReduceCount== 0)									
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidZeroCount== 0)													
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidBNPLCount== 0)																					
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoid2GOCount== 0)																									
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidSaleCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidRedeemCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidCashCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidCompCount == 0)
				&&(srAccumRec.stBankTotal[inTranCardType].stCardTotal[i].usVoidRefundCount== 0))

					continue;
				
				vdDebug_LogPrintf("Count[%d]", i); 
				inIITRead(i);
				memset(szStr, ' ', d_LINE_SIZE);
				memset (baTemp, 0x00, sizeof(baTemp));
				//strcpy(szStr,strIIT.szIssuerLabel);
				 if(strcmp(strIIT.szIssuerLabel, "BANCNET") == 0) //#00232 - When card process as DEBIT SALE terminal prints BANCNET instead of MCC DEBIT
				 		strcpy(szStr,"MCC DEBIT");    
				 else
					strcpy(szStr,strIIT.szIssuerLabel);
				
				CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
                vdCTOS_PrintAccumeByHostAndCard (inReportType, srAccumRec.stBankTotal[inTranCardType].stCardTotal[i]);
				fPrintTotal=TRUE;
			}
			//after print issuer total, then print host toal
			if(fPrintTotal == TRUE)
			{
			
				memset(szStr, ' ', d_LINE_SIZE);
				memset (baTemp, 0x00, sizeof(baTemp));
				strcpy(szStr,"GRAND TOTAL");
				CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
				CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
                vdCTOS_PrintAccumeByHostAndCard (inReportType, srAccumRec.stBankTotal[inTranCardType].stHOSTTotal); 
			}
		}
		else
		{
		
			memset(szStr, ' ', d_LINE_SIZE);
			memset (baTemp, 0x00, sizeof(baTemp));
			strcpy(szStr,srTransRec.szHostLabel);
			CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
			CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
            vdCTOS_PrintAccumeByHostAndCard (inReportType, srAccumRec.stBankTotal[inTranCardType].stHOSTTotal); 
		}
	}

    if(srAccumRec.fManualSettle == TRUE)
    {
        vdPrintTitleCenter("DELETED BATCH FOR");
		vdPrintTitleCenter("MANUAL POSTING");
    }
    else		
        vdPrintTitleCenter("SETTLEMENT CONFIRMED");	
	
	//print space one line
	CTOS_PrinterFline(d_LINE_DOT * 8);		
	
	return d_OK;	
}

void vdCTOSS_PrinterBMPPic(unsigned int usX,unsigned int y, const char *path)
{
	char szBmpfile[50+1];
	
	memset(szBmpfile, 0x00, sizeof(szBmpfile));
	sprintf(szBmpfile,"%s%s", LOCAL_PATH, path);
	
	CTOS_PrinterBMPPic(usX, szBmpfile);
	return ;
}

int inPrint(unsigned char *strPrint) 
{
	char szStr[46+1] = {0}; 
	BYTE baTemp[PAPER_X_SIZE * 64] = {0};

	memset(szStr, 0x00, sizeof(szStr));
	memcpy(szStr, strPrint, strlen(strPrint));

	memset (baTemp, 0x00, sizeof(baTemp));
	CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
	return CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);  
}

int inPrintLeftRight(unsigned char *strLeft, unsigned char *strRight, int inWidth) 
{
	char szStr[64+1] = {0}; 
	BYTE baTemp[PAPER_X_SIZE * 64] = {0};

	memset(szStr, 0x20, sizeof(szStr));
    memcpy(szStr, strLeft, strlen(strLeft));
    memcpy(&szStr[inWidth-strlen(strRight)], strRight, strlen(strRight));
	szStr[inWidth]=0x00;
	
	memset (baTemp, 0x00, sizeof(baTemp));
	CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
	return CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);  
}

/*albert - start - Aug2014 - compute crc*/
void vdCTOS_PrintCRC(void)
{
    int shHostIndex = 1, inNumOfMerchant=0;
    int inResult,inRet;
    unsigned char szCRC[8+1];
    char ucLineBuffer[d_LINE_SIZE];
    BYTE baTemp[PAPER_X_SIZE * 64];
	
    vduiLightOn();                

    //fix for issue #00092
    //Must display "Out of Paper..."
    if( printCheckPaper()==-1)
      return;
	
    shHostIndex = inCTOS_SelectHostSetting();
    if (shHostIndex == -1)
        return;

   //CTOS_LCDTClearDisplay();

    if (inMultiAP_CheckMainAPStatus() == d_OK)
    {
        inRet = inCTOS_MultiAPSaveData(d_IPC_CMD_PRINT_CRC);
        if(d_OK != inRet)
            return ;
    }
    else
    {
        if (inMultiAP_CheckSubAPStatus() == d_OK)
        {
            inRet = inCTOS_MultiAPGetData();
            if(d_OK != inRet)
                return ;

            inRet = inCTOS_MultiAPReloadHost();
            if(d_OK != inRet)
                return ;
        }
    }
		
    memset(szCRC, 0, sizeof(szCRC));
	vdComputeCRC(strHDT.ulCRC, szCRC);

    inCTOS_SelectFont(d_FONT_FNT_MODE,d_FONT_24x24,0," ");
    vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);


CTOS_PrinterSetHeatLevel(4);  

    vdSetPrintThreadStatus(1); //##00129

    fRePrintFlag = FALSE;
	
	//print Logo	
	if(strlen(strHDT.szHeaderLogoName))
		vdCTOSS_PrinterBMPPic(0, 0, strHDT.szHeaderLogoName);
	else
		vdCTOSS_PrinterBMPPic(0, 0, "logo.bmp");

    vdPrintTitleCenter("CRC REPORT");
    CTOS_PrinterFline(d_LINE_DOT * 1);

	vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);
	vdCTOS_SetDateTime();
	
    printDateTime();
    CTOS_PrinterFline(d_LINE_DOT * 1);

    memset(baTemp, 0x00, sizeof(baTemp));
    sprintf(baTemp, "HOST: %s", strHDT.szHostLabel);
	inPrint(baTemp);

    {
        FILE* file;
        int nLen;
        unsigned char chBuffer[1024];		
		memset(chBuffer, 0, 1024);

		if ((file = fopen (strHDT.szAPName, "rb")) != NULL)
		{
			while (nLen = fread (chBuffer, 1, 256, file))
			{
			}

            memset(baTemp, 0x00, sizeof(baTemp));
            sprintf(baTemp, "CRC: %02x %02x %02x %02x", wub_lrc((unsigned char *) &chBuffer[0], 64),
			wub_lrc((unsigned char *) &chBuffer[63], 64),
			wub_lrc((unsigned char *) &chBuffer[127], 64),
			wub_lrc((unsigned char *) &chBuffer[191], 64));
            inPrint(baTemp);
			fclose (file);
		}
    }
	
    CTOS_PrinterFline(d_LINE_DOT * 8);
}
/*albert - end - Aug2014 - compute crc*/
void vdCTOS_HostInfo(void){
int shHostIndex = 1, inNumOfMerchant=0;
int inResult,inRet;
unsigned char szCRC[8+1];
char ucLineBuffer[d_LINE_SIZE];
BYTE baTemp[PAPER_X_SIZE * 64];
int inLoop = 0;
char szBillerName[1024] = {0};
char szBillerCode[1024] = {0};
char szStr[d_LINE_SIZE + 1];
BYTE szTempBuf[12+1];
BYTE szBuf[50];

vdDebug_LogPrintf("-->>vdCTOS_HostInfo[START]");

vduiLightOn();								

//fix for issue #00092
//Must display "Out of Paper..."
if( printCheckPaper()==-1)
	return;


shHostIndex = inCTOS_SelectHostSetting();
if (shHostIndex == -1)
	return;

CTOS_LCDTClearDisplay();

#if 0
if (inMultiAP_CheckMainAPStatus() == d_OK)
{
	inRet = inCTOS_MultiAPSaveData(d_IPC_CMD_PRINT_HOST_INFO);
	if(d_OK != inRet)
		  return ;
}
else
{
	if (inMultiAP_CheckSubAPStatus() == d_OK)
	{
		inRet = inCTOS_MultiAPGetData();
		if(d_OK != inRet)
			return ;
		
		inRet = inCTOS_MultiAPReloadHost();
		if(d_OK != inRet)
			return ;
	}
}	 
//inRet = inCTOS_MultiAPReloadHost();
//if(d_OK != inRet)
	//return ;
#endif

inCTOS_SelectFont(d_FONT_FNT_MODE,d_FONT_24x24,0," ");
vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);

CTOS_PrinterSetHeatLevel(4);  

    vdSetPrintThreadStatus(1); //##00129

	//print Logo	
	if(strlen(strHDT.szHeaderLogoName))
		vdCTOSS_PrinterBMPPic(0, 0, strHDT.szHeaderLogoName);
	else
		vdCTOSS_PrinterBMPPic(0, 0, "logo.bmp");

vdPrintTitleCenter("HOST INFO REPORT");
CTOS_PrinterFline(d_LINE_DOT * 1);

vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);

vdCTOS_SetDateTime();

printDateTime();

inPrint("-------------------------------");

memset(szStr, 0x00, d_LINE_SIZE);
sprintf(szStr, "HOST        : %s", (char *)strHDT.szHostLabel);
inPrint(szStr);

memset(szTempBuf, 0x00, sizeof(szTempBuf));
wub_hex_2_str(strHDT.szTPDU,szTempBuf,5);
sprintf(szStr, "TPDU        : %s", szTempBuf);
inPrint(szStr);

memset(szTempBuf, 0x00, sizeof(szTempBuf));
wub_hex_2_str(strHDT.szNII,szTempBuf,2);
sprintf(szStr, "NII         : %s", szTempBuf);
inPrint(szStr);

memset(szStr, 0x00, d_LINE_SIZE);
sprintf(szStr, "PRI TEL NUM : %s", (char *)strCPT.szPriTxnPhoneNumber);
inPrint(szStr);

memset(szStr, 0x00, d_LINE_SIZE);
sprintf(szStr, "SEC TEL NUM : %s", (char *)strCPT.szSecTxnPhoneNumber);
inPrint(szStr);

memset(szStr, 0x00, d_LINE_SIZE);
sprintf(szStr, "PRI IP      : %s", (char *)strCPT.szPriTxnHostIP);
inPrint(szStr);

memset(szStr, 0x00, d_LINE_SIZE);
sprintf(szStr, "PRI IP PORT : %04ld", strCPT.inPriTxnHostPortNum);
inPrint(szStr);

memset(szStr, 0x00, d_LINE_SIZE);
sprintf(szStr, "SEC IP      : %s", (char *)strCPT.szSecTxnHostIP);
inPrint(szStr);

memset(szStr, 0x00, d_LINE_SIZE);
sprintf(szStr, "SEC IP PORT : %04ld", strCPT.inSecTxnHostPortNum);
inPrint(szStr);

// FIX FOR ISSUE #00099 Serial Number & CRC must be printed in Function 1 receipt
#if 1
{// print Serial Number

char szTermSerialNumber[15]; // print terminal serial number on all txn receipt - mfl
char szStr1[35+1]; // print terminal serial number on all txn receipt - mfl

memset(szStr1, 0x00, sizeof(szStr1));
memset (baTemp, 0x00, sizeof(baTemp));			
memset(szTermSerialNumber,0x00,sizeof(szTermSerialNumber));

CTOS_GetFactorySN(szTermSerialNumber);		 
			szTermSerialNumber[15]=0;

//CTOS_PrinterPutString(szTermSerialNumber);

sprintf(szStr1, "SERIAL NO   : %s", szTermSerialNumber);

CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr1, &stgFONT_ATTRIB);
CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
}
// print CRC
{
        FILE* file;
        int nLen;
        unsigned char chBuffer[1024];		
		memset(chBuffer, 0, 1024);

		if ((file = fopen (strHDT.szAPName, "rb")) != NULL)
		{
			while (nLen = fread (chBuffer, 1, 256, file))
			{
			}

            memset(baTemp, 0x00, sizeof(baTemp));
            sprintf(baTemp, "CRC         : %02x %02x %02x %02x", wub_lrc((unsigned char *) &chBuffer[0], 64),
			wub_lrc((unsigned char *) &chBuffer[63], 64),
			wub_lrc((unsigned char *) &chBuffer[127], 64),
			wub_lrc((unsigned char *) &chBuffer[191], 64));
            inPrint(baTemp);
			fclose (file);
		}
    }


#endif

inPrint("-------------------------------");

inMMTReadNumofRecords(strHDT.inHostIndex,&inNumOfMerchant);

vdDebug_LogPrintf("[inNumOfMerchant]-[%d]strHDT.inHostIndex[%d]", inNumOfMerchant,strHDT.inHostIndex);
for(inLoop=1; inLoop <= inNumOfMerchant;inLoop++)
{
	 if((inResult = inMMTReadRecord(strHDT.inHostIndex,inLoop)) !=d_OK)
	 {
			 vdDebug_LogPrintf("[read MMT fail]-Mitid[%d]strHDT.inHostIndex[%d]inResult[%d]", inLoop,strHDT.inHostIndex,inResult);
			 continue;
			 //break;
	 }
	 else 
	 {
			 if(strMMT[0].fMMTEnable)
			 {	
					 memset(szStr, 0x00, sizeof(szStr));
					 sprintf(szStr, "  MERCHANT : %s", strMMT[0].szMerchantName); 											 
					 inPrint(szStr);

					 memset(szStr, 0x00, sizeof(szStr));
					 sprintf(szStr, "  TID      : %s", strMMT[0].szTID); 											 
					 inPrint(szStr);

					 memset(szStr, 0x00, sizeof(szStr));
					 sprintf(szStr, "  MID      : %s", strMMT[0].szMID); 											 
					 inPrint(szStr);

					 memset(szStr, 0x00, sizeof(szStr));
					 memset(szBuf, 0x00, sizeof(szBuf));
					 wub_hex_2_str(strMMT[0].szBatchNo, szBuf, 3);
					 sprintf(szStr, "  BATCH NO : %s", szBuf); 											 
					 inPrint(szStr);
					 CTOS_PrinterFline(d_LINE_DOT * 1);

			 }										

	 }
}

CTOS_PrinterFline(d_LINE_DOT * 5);

vdDebug_LogPrintf("-->>vdCTOS_HostInfo[END]");
}

int ushCTOS_ePadSignature(void)
{
	if (FALSE ==strTCT.fSignatureFlag)
		return d_OK;
	
	ePad_SignatureCaptureLib();
	return d_OK;
}

int ushCTOS_ePadPrintSignature(void)
{
	if (FALSE ==strTCT.fSignatureFlag)
		return d_OK;
	
	ePad_PrintSignatureCaptureLib();
	return d_OK;
}


int ushCTOS_ClearePadSignature(void)
{
	if (FALSE ==strTCT.fSignatureFlag)
		return d_OK;
	
	ePad_ClearSignatureCaptureLib();
	return d_OK;
}

USHORT ushCTOS_PrintLoyaltyBody(int page)
{	
    char szStr[d_LINE_SIZE + 1];
    char szTemp[d_LINE_SIZE + 1];
    char szTemp1[d_LINE_SIZE + 1];
    char szTemp3[d_LINE_SIZE + 1];
    char szTemp4[d_LINE_SIZE + 1];
    char szTemp5[d_LINE_SIZE + 1];
    char szFormatPAN[strlen(srTransRec.szPAN) + 7];//to account for space as in PAN format and to include additional PAN no. 7 has been added -Meena 08/01/2012
    int inFmtPANSize;
    BYTE baTemp[PAPER_X_SIZE * 64];
    USHORT result;
    int num,i,inResult;
    unsigned char tucPrint [24*4+1];	
    BYTE   EMVtagVal[64];
    USHORT EMVtagLen; 
    short spacestring;
    BYTE   key;
    struct LOYALTY_DATA stLoyData;
    int inIndex=0;
TRANS_DATA_TABLE *srTransPara;

//    CTOS_PrinterPutString("ushCTOS_PrintLoyaltyBody");

#if 0
    if(strTCT.fDemo == 1)
    {
        memset(srTransRec.szLoyaltyData, 0x00, sizeof(srTransRec.szLoyaltyData));
        memcpy(srTransRec.szLoyaltyData, "0000000011110000000022220000000033330000000044400000000555000000006660000000000770000000088800000000999 R", 105);
    }

    memset(&stLoyData, 0x00, sizeof(struct LOYALTY_DATA));
   // vdExtractLoyaltyData(&stLoyData, &srTransRec.szLoyaltyData);
vdExtractLoyaltyData(&stLoyData, &srTransPara.szLoyaltyData);    
#endif


	if(d_FIRST_PAGE == page)
	{
		CTOS_PrinterFline(d_LINE_DOT * 1);
	
		vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0); 
		if(srTransRec.byTransType == LOY_BAL_INQ)
		vdPrintCenter("POINTS INQUIRY");
		else if(srTransRec.byTransType == LOY_REDEEM_5050 || srTransRec.byTransType == LOY_REDEEM_VARIABLE)
		vdPrintCenter("REAL TIME REWARDS REDEMPT.");// fix for wrong void redeem printout - 05252015
		else if(srTransRec.byTransType == VOID && srTransRec.byOrgTransType == LOY_REDEEM_VARIABLE || srTransRec.byOrgTransType == LOY_REDEEM_5050)//else if(srTransRec.byTransType == VOID_REDEEM)
		vdPrintCenter("VOID REAL TIME REWARDS REDEMPT.");

		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);	

		//CTOS_PrinterFline(d_LINE_DOT * 1);

		memset (szTemp, 0x00, sizeof(szTemp));
		vdCTOS_FormatPAN(strIIT.szMaskMerchantCopy, srTransRec.szPAN, szTemp);
		inPrintLeftRight("CARD NUMBER", szTemp, 46);

		TrimTrail(srTransRec.szCardholderName);
		inPrintLeftRight("CARDHOLDER NAME", srTransRec.szCardholderName, 46);

		CTOS_PrinterFline(d_LINE_DOT * 1);

		if(srTransRec.byTransType == LOY_BAL_INQ)
		{
//    CTOS_PrinterPutString("LOY_BAL_INQ");
    /*CTOS_PrinterPutString(srTransRec.szAmount1);
    CTOS_PrinterPutString(srTransRec.szAmount2);
    CTOS_PrinterPutString(srTransRec.szAmount3);
    CTOS_PrinterPutString(srTransRec.szAmount4);
    CTOS_PrinterPutString(srTransRec.szAmount5);	
    CTOS_PrinterPutString(srTransRec.szAmount6);*/
		
		    memset (szTemp, 0x00, sizeof(szTemp));	
	            //vdCTOS_FormatAmount("NNN,NNN,NNn.nn", stLoyData.szPointBalance, szTemp);
	            vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount1, szTemp);
	            //sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szSaleAmount)/100), (atol(stLoyData.szSaleAmount)%100)); 
	            inPrintLeftRight("POINTS BALANCE:", szTemp, 46);
	            //inPrintLeftRight("POINTS BALANCE:", srTransRec.szAmount1, 46);
	   		
	   	    memset (szTemp, 0x00, sizeof(szTemp));	
	            vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount2, szTemp);	//ePurse Balance
	    		//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szRedeemAmountAmount)/100), (atol(stLoyData.szRedeemAmountAmount)%100));
		    //vdCTOS_FormatAmount("NNN,NNN,NNn.nn", srTransRec.szEPurseBalance, szTemp);	    		
	            inPrintLeftRight("PESO VALUE OF POINTS:", szTemp, 46);			
	            //inPrintLeftRight("PESO VALUE OF POINTS:", srTransRec.szAmount4, 46);			
	            
		}
		else if(srTransRec.byTransType == LOY_REDEEM_5050 || srTransRec.byTransType == LOY_REDEEM_VARIABLE)
		{
		        // adjust as per specs 05282015
			// sales amount
			memset(szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount4, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szSaleAmount)/100), (atol(stLoyData.szSaleAmount)%100)); 
			inPrintLeftRight("TOTAL AMOUNT DUE", szTemp, 46);

			// redeemed amount		
			memset(szTemp, 0x00, sizeof(szTemp));        
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount5, szTemp);	
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szRedeemAmountAmount)/100), (atol(stLoyData.szRedeemAmountAmount)%100));
			inPrintLeftRight("AMOUNT CHARGE TO POINTS", szTemp, 46);

			//Net sales Amount
			memset(szTemp, 0x00, sizeof(szTemp));        
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount6, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szNetSalesAmount)/100), (atol(stLoyData.szNetSalesAmount)%100));
			inPrintLeftRight("AMOUNT CHARGE TO C. CARD", szTemp, 46);

			CTOS_PrinterFline(d_LINE_DOT * 1);

			//Beginning points balance
			memset (szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount1, szTemp);	
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szBeginPointBalance)/100), (atol(stLoyData.szBeginPointBalance)%100));
			inPrintLeftRight("BEGINNING BALANCE POINTS", szTemp, 46);

			//redeemed points
			memset (szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount2, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szRedeemPoints)/100), (atol(stLoyData.szRedeemPoints)%100));
			inPrintLeftRight("POINTS USED FOR PAYMENT", szTemp, 46);

			//points balance
			memset (szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount3, szTemp);	
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szPointBalance)/100), (atol(stLoyData.szPointBalance)%100));
			inPrintLeftRight("ENDING BALANCE POINTS", szTemp, 46);
		}
		else if(srTransRec.byTransType == VOID && srTransRec.byOrgTransType == LOY_REDEEM_VARIABLE || srTransRec.byOrgTransType == LOY_REDEEM_5050)//else if(srTransRec.byTransType == VOID_REDEEM)
		{// fix for wrong void redeem printout
    			char szAmtBuf[24+1] = { 0 };
		
			memset(szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount1, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szSaleAmount)/100), (atol(stLoyData.szSaleAmount)%100)); 
			inPrintLeftRight("AMOUNT REVERSED", szTemp, 46);

			// convert points for void
			memset(szAmtBuf, 0x00, sizeof(szAmtBuf));        
			srTransRec.szAmount5[0]='0';
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount2, szTemp);
			strcpy(szAmtBuf, "-");
			strcat(szAmtBuf, szTemp);			
			inPrintLeftRight("AMOUNT REVERSED TO POINTS", szAmtBuf, 46);

			memset(szTemp, 0x00, sizeof(szTemp));        
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount3, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szNetSalesAmount)/100), (atol(stLoyData.szNetSalesAmount)%100));
			inPrintLeftRight("AMOUNT REVERSED TO CARD", szTemp, 46);

			CTOS_PrinterFline(d_LINE_DOT * 1);

			memset (szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount4, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szBeginPointBalance)/100), (atol(stLoyData.szBeginPointBalance)%100));
			inPrintLeftRight("BEGINNING BALANCE POINTS", szTemp, 46);


			memset (szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount5, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szRedeemPoints)/100), (atol(stLoyData.szRedeemPoints)%100));
			inPrintLeftRight("POINTS REVERSED", szTemp, 46);

			memset (szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount6, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szPointBalance)/100), (atol(stLoyData.szPointBalance)%100));
			inPrintLeftRight("ENDING BALANCE POINTS", szTemp, 46);	
		}
			vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);
	}
	else if((d_SECOND_PAGE == page)||(d_THIRD_PAGE == page))
	{
		CTOS_PrinterFline(d_LINE_DOT * 1);
	
		vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0); 
		if(srTransRec.byTransType == LOY_BAL_INQ)
		vdPrintCenter("POINTS INQUIRY");
		else if(srTransRec.byTransType == LOY_REDEEM_5050 || srTransRec.byTransType == LOY_REDEEM_VARIABLE)
		vdPrintCenter("REAL TIME REWARDS REDEMPT.");// fix for wrong void redeem printout - 05252015
		else if(srTransRec.byTransType == VOID && srTransRec.byOrgTransType == LOY_REDEEM_VARIABLE || srTransRec.byOrgTransType == LOY_REDEEM_5050)//else if(srTransRec.byTransType == VOID_REDEEM)
		vdPrintCenter("VOID REAL TIME REWARDS REDEMPT.");

		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);	

		//CTOS_PrinterFline(d_LINE_DOT * 1);

		memset (szTemp, 0x00, sizeof(szTemp));
		vdCTOS_FormatPAN(strIIT.szMaskMerchantCopy, srTransRec.szPAN, szTemp);
		inPrintLeftRight("CARD NUMBER", szTemp, 46);

		TrimTrail(srTransRec.szCardholderName);
		inPrintLeftRight("CARDHOLDER NAME", srTransRec.szCardholderName, 46);

		CTOS_PrinterFline(d_LINE_DOT * 1);

		if(srTransRec.byTransType == LOY_BAL_INQ)
		{
			memset(szTemp, 0x00, sizeof(szTemp));
			//vdCTOS_FormatAmount("NNN,NNN,NNn.nn", stLoyData.szPointBalance, szTemp);
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount1, szTemp); // Beginning Points Balance
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szSaleAmount)/100), (atol(stLoyData.szSaleAmount)%100)); 
			inPrintLeftRight("POINTS BALANCE:", szTemp, 46);

			memset(szTemp, 0x00, sizeof(szTemp));        
			//vdCTOS_FormatAmount("NNN,NNN,NNn.nn", stLoyData.szEPurseBalance, szTemp);	
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szRedeemAmountAmount)/100), (atol(stLoyData.szRedeemAmountAmount)%100));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount2, szTemp);	    // ePurse Balance		
			inPrintLeftRight("PESO VALUE OF POINTS:", szTemp, 46);			
		}
		else if(srTransRec.byTransType == LOY_REDEEM_5050 || srTransRec.byTransType == LOY_REDEEM_VARIABLE)
		{
			// sales amount
			memset(szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount4, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szSaleAmount)/100), (atol(stLoyData.szSaleAmount)%100)); 
			inPrintLeftRight("TOTAL AMOUNT DUE", szTemp, 46);

			// redeemed amount		
			memset(szTemp, 0x00, sizeof(szTemp));        
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount5, szTemp);	
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szRedeemAmountAmount)/100), (atol(stLoyData.szRedeemAmountAmount)%100));
			inPrintLeftRight("AMOUNT CHARGE TO POINTS", szTemp, 46);

			//Net sales Amount
			memset(szTemp, 0x00, sizeof(szTemp));        
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount6, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szNetSalesAmount)/100), (atol(stLoyData.szNetSalesAmount)%100));
			inPrintLeftRight("AMOUNT CHARGE TO C. CARD", szTemp, 46);

			CTOS_PrinterFline(d_LINE_DOT * 1);

			//Beginning points balance
			memset (szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount1, szTemp);	
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szBeginPointBalance)/100), (atol(stLoyData.szBeginPointBalance)%100));
			inPrintLeftRight("BEGINNING BALANCE POINTS", szTemp, 46);

			//redeemed points
			memset (szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount2, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szRedeemPoints)/100), (atol(stLoyData.szRedeemPoints)%100));
			inPrintLeftRight("POINTS USED FOR PAYMENT", szTemp, 46);

			//points balance
			memset (szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nnv", srTransRec.szAmount3, szTemp);	
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szPointBalance)/100), (atol(stLoyData.szPointBalance)%100));
			inPrintLeftRight("ENDING BALANCE POINTS", szTemp, 46);
		}
		else if(srTransRec.byTransType == VOID && srTransRec.byOrgTransType == LOY_REDEEM_VARIABLE || srTransRec.byOrgTransType == LOY_REDEEM_5050)//else if(srTransRec.byTransType == VOID_REDEEM)
		{// fix for wrong void redeem printout - 05252015

    			char szAmtBuf[24+1] = { 0 };
		
			memset(szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount1, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szSaleAmount)/100), (atol(stLoyData.szSaleAmount)%100)); 
			inPrintLeftRight("AMOUNT REVERSED", szTemp, 46);

#if 0
			memset(szTemp, 0x00, sizeof(szTemp));        
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount5, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szRedeemAmountAmount)/100), (atol(stLoyData.szRedeemAmountAmount)%100));
			inPrintLeftRight("AMOUNT REVERSED TO POINTS", szTemp, 46);
#else
			// convert points for void
			memset(szAmtBuf, 0x00, sizeof(szAmtBuf));        
			srTransRec.szAmount5[0]='0';
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount2, szTemp);
			strcpy(szAmtBuf, "-");
			strcat(szAmtBuf, szTemp);	//Incorrect Merchant & Bank copy receipt on Void RTR		- #00190
			inPrintLeftRight("AMOUNT REVERSED TO POINTS", szAmtBuf, 46);
			

#endif
			memset(szTemp, 0x00, sizeof(szTemp));        
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount3, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szNetSalesAmount)/100), (atol(stLoyData.szNetSalesAmount)%100));
			inPrintLeftRight("AMOUNT REVERSED TO CARD", szTemp, 46);

			CTOS_PrinterFline(d_LINE_DOT * 1);

			memset (szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount4, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szBeginPointBalance)/100), (atol(stLoyData.szBeginPointBalance)%100));
			inPrintLeftRight("BEGINNING BALANCE POINTS", szTemp, 46);


			memset (szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount5, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szRedeemPoints)/100), (atol(stLoyData.szRedeemPoints)%100));
			inPrintLeftRight("POINTS REVERSED", szTemp, 46);

			memset (szTemp, 0x00, sizeof(szTemp));
			vdCTOS_FormatAmount("NNN,NNN,NNN,NNn.nn", srTransRec.szAmount6, szTemp);
			//sprintf(szTemp, "%10lu.%02lu", (atol(stLoyData.szPointBalance)/100), (atol(stLoyData.szPointBalance)%100));
			inPrintLeftRight("ENDING BALANCE: POINTS", szTemp, 46);	
		}
        vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);	
	}
	return d_OK;	
	
}

USHORT ushCTOS_PrintLoyaltyFooter(int page)
{		
    BYTE   EMVtagVal[64];
    USHORT EMVtagLen; 
	int result;
    char szStr[35 + 1];
  	CTOS_RTC SetRTC;
	char szYear[3];
	char szTempDate[d_LINE_SIZE + 1];
    char szTemp[d_LINE_SIZE + 1];
    char szTemp2[d_LINE_SIZE + 1];
    char szTemp3[d_LINE_SIZE + 1];
    char szTemp4[d_LINE_SIZE + 1];
    char szTermSerialNum[15+1]; // print terminal serial number on all txn receipt - mfl
    BYTE baTemp[PAPER_X_SIZE * 64];


    //CTOS_PrinterPutString("ushCTOS_PrintLoyaltyFooter");
    //CTOS_PrinterPutString(srTransRec.szRRN); //srTransRec.szAuthCode
    //CTOS_PrinterPutString(srTransRec.szAuthCode);


	CTOS_RTCGet(&SetRTC);
	sprintf(szYear ,"%02d",SetRTC.bYear);
	memcpy(srTransRec.szYear,szYear,2);
	
	if(page == d_FIRST_PAGE)
	{
		memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
		EMVtagLen = 0;
		
		DebugAddINT("ushCTOS_PrintFooter,mode",srTransRec.byEntryMode);  
		if(srTransRec.byEntryMode==CARD_ENTRY_ICC)
		{
			EMVtagLen = 3;
			memcpy(EMVtagVal, srTransRec.stEMVinfo.T9F34, EMVtagLen);
			if((EMVtagVal[2]& 0x0F) == 2)
			{   
				CTOS_PrinterFline(d_LINE_DOT * 1);
				CTOS_PrinterPutString("*****NO SIGNATURE REQUIRED*****");
				CTOS_PrinterPutString("     (PIN VERIFY SUCCESS)");
			}
			else
			{
			//CTOS_PrinterFline(d_LINE_DOT * 3);
			}
		}
	        else
	        {
			//00171 - Swipe RTR sale/void Receipt has signature line printed on customer receipt.
			/*if((strCDT.inType != DEBIT_CARD) && (srTransRec.byTransType != LOY_BAL_INQ)
				&& (srTransRec.byTransType != LOY_REDEEM_5050)
				&& (srTransRec.byTransType != LOY_REDEEM_VARIABLE)) // mfl
			{
				CTOS_PrinterFline(d_LINE_DOT * 3);
				CTOS_PrinterPutString("SIGN:_______________________________________");
				TrimTrail(srTransRec.szCardholderName);
				vdPrintCenter(srTransRec.szCardholderName); 
			}*/
	        }

		ushCTOS_ePadPrintSignature();
		
		CTOS_PrinterFline(d_LINE_DOT * 1);
		
		//ushCTOS_PrintAgreement();
		if(srTransRec.byTransType == LOY_BAL_INQ)	
		{	
    vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);
		
			if(strlen(strMMT[0].szRctFoot1) > 0)
				vdPrintCenter(strMMT[0].szRctFoot1);
			if(strlen(strMMT[0].szRctFoot2) > 0)
		    	vdPrintCenter(strMMT[0].szRctFoot2);
			if(strlen(strMMT[0].szRctFoot3) > 0)
		    	vdPrintCenter(strMMT[0].szRctFoot3);
		}
		
		CTOS_PrinterFline(d_LINE_DOT * 1);

		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);	

		memset(szTemp, 0x00, sizeof(szTemp));
		memset(szTemp2, 0x00, sizeof(szTemp2));
		memset(szTemp3, 0x00, sizeof(szTemp3));
		memset(szTemp4, 0x00, sizeof(szTemp4));
		wub_hex_2_str(srTransRec.szDate, szTemp,DATE_BCD_SIZE);
		wub_hex_2_str(srTransRec.szTime, szTemp2,TIME_BCD_SIZE);
		memset(szTempDate, 0x00, sizeof(szTempDate));
		sprintf(szTempDate, "%02lu%02lu%02lu", atol(srTransRec.szYear), atol(szTemp)/100, atol(szTemp)%100);
		vdCTOS_FormatDate(szTempDate);
		sprintf(szTemp3, "DATE: %s", szTempDate);
		sprintf(szTemp4, "TIME: %02lu:%02lu:%02lu", atol(szTemp2)/10000,atol(szTemp2)%10000/100, atol(szTemp2)%100);
		inPrintLeftRight(szTemp3, szTemp4, 46);

		memset(szTemp, 0x00, sizeof(szTemp));
		memset(szTemp2, 0x00, sizeof(szTemp2));
		sprintf(szTemp, "TID: %s", srTransRec.szTID);
		sprintf(szTemp2, "MID: %s", srTransRec.szMID);
		inPrintLeftRight(szTemp, szTemp2, 46);

		memset(szTemp, 0x00, sizeof(szTemp));
		memset(szTemp2, 0x00, sizeof(szTemp2));
		memset(szTemp3, 0x00, sizeof(szTemp3));
		memset(szTemp4, 0x00, sizeof(szTemp4));
		wub_hex_2_str(srTransRec.szBatchNo,szTemp,3);
		wub_hex_2_str(srTransRec.szInvoiceNo, szTemp2, INVOICE_BCD_SIZE);
		sprintf(szTemp3, "BATCH NUM: %s", szTemp);
		sprintf(szTemp4, "TRACE NO.: %s", szTemp2);
		inPrintLeftRight(szTemp3, szTemp4, 46);


		// PRINT RRN AND HOST
		memset(szTemp, 0x00, sizeof(szTemp));
		memset(szStr, 0x00, sizeof(szStr));
		memset(szTemp3, 0x00, sizeof(szTemp3));
		memset(szTemp4, 0x00, sizeof(szTemp4));
		//wub_hex_2_str(srTransRec.szRRN,szTemp,3);
		//wub_hex_2_str(srTransRec.szHostLabel, szTemp2, INVOICE_BCD_SIZE);

		//sprintf(szTemp3, "REF NO.   : %s", szTemp);
            	sprintf(szTemp3, "REF NO.: %s", srTransRec.szRRN);		//Terminal prints incorrect value of RRN for RTR Points Inquiry and RTR Redeem
    		sprintf(szTemp4, "HOST: %s", srTransRec.szHostLabel);		
		inPrintLeftRight(szTemp3, szTemp4, 46);

		// PRINT APPR CODE
		memset(szStr, 0x00, d_LINE_SIZE);
		sprintf(szStr, "APPR. CODE: %s", srTransRec.szAuthCode);
		result=inPrint(szStr);


#if 0
		memset(szStr, 0x00, d_LINE_SIZE);
		sprintf(szStr, "REF NO.   : %s", srTransRec.szRRN);
		result=inPrint(szStr);

		memset(szStr, 0x00, d_LINE_SIZE);
		sprintf(szStr, "APPR. CODE: %s", srTransRec.szAuthCode);
		result=inPrint(szStr);
//#else
        //Reference num
        if(strCDT.inType != DEBIT_CARD)
        {
            memset(szStr, ' ', d_LINE_SIZE);
            memset (baTemp, 0x00, sizeof(baTemp));					
            memset(szStr, ' ', d_LINE_SIZE);
            sprintf(szStr, "REF NO.   : %s", srTransRec.szRRN);
            memset (baTemp, 0x00, sizeof(baTemp));		
            CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
        }
		
		//Auth response code
		memset(szStr, ' ', d_LINE_SIZE);
		memset (baTemp, 0x00, sizeof(baTemp));					
		memset(szStr, ' ', d_LINE_SIZE);
		sprintf(szStr, "APPR. CODE: %s", srTransRec.szAuthCode);
		memset (baTemp, 0x00, sizeof(baTemp));		
		CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);

    	printHostLabel(); // mfl	

#endif

        if(strTCT.fProductCode == TRUE)
        {
            memset(szStr, 0x00, d_LINE_SIZE);
            sprintf(szStr, "PRODUCT CODE: %s", srTransRec.szProductCode);
            result=inPrint(szStr);
        }

        if(strTCT.fCustomerNo == TRUE)
        {
	        memset(szStr, 0x00, d_LINE_SIZE);
            sprintf(szStr, "CUSTOMER NUMBER: %s", srTransRec.szCustomerNo);
	        result=inPrint(szStr);
        }

/*
Minimum output buffer size is 16 bytes.
The last digit is the check code of factory serial number. The check code is calculated  by  exclusive-OR (XOR) the first 15 digits.
E.I 000001180002315[=]
*/		
#if 1
	//Terminal serial number - mfl		
	memset(szTemp4, 0x00, sizeof(szTemp4));
	memset(szTemp, ' ', d_LINE_SIZE);
    	memset (baTemp, 0x00, sizeof(baTemp));			
	memset(szTermSerialNum, 0x00, sizeof(szTermSerialNum)); 
	CTOS_GetFactorySN(szTermSerialNum);		 
			szTermSerialNum[15]=0;
	
	//sprintf(szStr, "TERMINAL SERIAL NUM: %s", szTermSerialNum);	 
	sprintf(szStr, "TSN: %s", szTermSerialNum);
	
         CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
         result = CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
	//
#endif		
        vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);

		if(strHDT.fFooterLogo == TRUE)	
            vdCTOSS_PrinterBMPPic(0, 0, "footer.bmp");
			
		CTOS_PrinterFline(d_LINE_DOT * 1); 
		CTOS_PrinterPutString("   ***** CUSTOMER COPY *****  ");
	}
	else if(page == d_SECOND_PAGE)
	{
		memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
		EMVtagLen = 0;
		
		DebugAddINT("ushCTOS_PrintFooter,mode",srTransRec.byEntryMode);  
		if(srTransRec.byEntryMode==CARD_ENTRY_ICC)
		{
			EMVtagLen = 3;
			memcpy(EMVtagVal, srTransRec.stEMVinfo.T9F34, EMVtagLen);
			if((EMVtagVal[2]& 0x0F) == 2)
            		{         
		                CTOS_PrinterFline(d_LINE_DOT * 1);
		                CTOS_PrinterPutString("*****NO SIGNATURE REQUIRED*****");
		                CTOS_PrinterPutString("     (PIN VERIFY SUCCESS)");
           		 }
            		else
            		{
				if((strCDT.inType != DEBIT_CARD) && (srTransRec.byTransType != LOY_BAL_INQ)) // mfl

				{
					CTOS_PrinterFline(d_LINE_DOT * 2);
					CTOS_PrinterPutString("SIGN:_______________________________________");
					TrimTrail(srTransRec.szCardholderName);
					vdPrintCenter(srTransRec.szCardholderName); 
				}
            		}
		}
        else
        {
			if((strCDT.inType != DEBIT_CARD) && (srTransRec.byTransType != LOY_BAL_INQ)) // mfl
			{
				CTOS_PrinterFline(d_LINE_DOT * 2);
				CTOS_PrinterPutString("SIGN:_______________________________________");
				TrimTrail(srTransRec.szCardholderName);
				vdPrintCenter(srTransRec.szCardholderName); 
			}
        }

		ushCTOS_ePadPrintSignature();

		CTOS_PrinterFline(d_LINE_DOT * 1);

		//ushCTOS_PrintAgreement();
		if(srTransRec.byTransType == LOY_BAL_INQ)	
		{	
			if(strlen(strMMT[0].szRctFoot1) > 0)
			vdPrintCenter(strMMT[0].szRctFoot1);
			if(strlen(strMMT[0].szRctFoot2) > 0)
			vdPrintCenter(strMMT[0].szRctFoot2);
			if(strlen(strMMT[0].szRctFoot3) > 0)
			vdPrintCenter(strMMT[0].szRctFoot3);
		}

		CTOS_PrinterFline(d_LINE_DOT * 1);

		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);	
		//vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);

		memset(szTemp, 0x00, sizeof(szTemp));
		memset(szTemp2, 0x00, sizeof(szTemp2));
		memset(szTemp3, 0x00, sizeof(szTemp3));
		memset(szTemp4, 0x00, sizeof(szTemp4));
		wub_hex_2_str(srTransRec.szDate, szTemp,DATE_BCD_SIZE);
		wub_hex_2_str(srTransRec.szTime, szTemp2,TIME_BCD_SIZE);
		memset(szTempDate, 0x00, sizeof(szTempDate));
		sprintf(szTempDate, "%02lu%02lu%02lu", atol(srTransRec.szYear), atol(szTemp)/100, atol(szTemp)%100);
		vdCTOS_FormatDate(szTempDate);
		sprintf(szTemp3, "DATE: %s", szTempDate);
		sprintf(szTemp4, "TIME: %02lu:%02lu:%02lu", atol(szTemp2)/10000,atol(szTemp2)%10000/100, atol(szTemp2)%100);
		inPrintLeftRight(szTemp3, szTemp4, 46);

		memset(szTemp, 0x00, sizeof(szTemp));
		memset(szTemp2, 0x00, sizeof(szTemp2));
		sprintf(szTemp, "TID: %s", srTransRec.szTID);
		sprintf(szTemp2, "MID: %s", srTransRec.szMID);
		inPrintLeftRight(szTemp, szTemp2, 46);

		memset(szTemp, 0x00, sizeof(szTemp));
		memset(szTemp2, 0x00, sizeof(szTemp2));
		memset(szTemp3, 0x00, sizeof(szTemp3));
		memset(szTemp4, 0x00, sizeof(szTemp4));
		wub_hex_2_str(srTransRec.szBatchNo,szTemp,3);
		wub_hex_2_str(srTransRec.szInvoiceNo, szTemp2, INVOICE_BCD_SIZE);
		sprintf(szTemp3, "BATCH NUM: %s", szTemp);
		sprintf(szTemp4, "TRACE NO.: %s", szTemp2);
		inPrintLeftRight(szTemp3, szTemp4, 46);


		// PRINT RRN AND HOST
		memset(szTemp, 0x00, sizeof(szTemp));
		memset(szTemp2, 0x00, sizeof(szTemp2));
		memset(szTemp3, 0x00, sizeof(szTemp3));
		memset(szTemp4, 0x00, sizeof(szTemp4));
		//wub_hex_2_str(srTransRec.szRRN,szTemp,3);
		//wub_hex_2_str(srTransRec.szHostLabel, szTemp2, INVOICE_BCD_SIZE);

		//sprintf(szTemp3, "REF NO.   : %s", szTemp);
		//sprintf(szTemp4, "  HOST     : %s", szTemp2);
            	sprintf(szTemp3, "REF NO.: %s", srTransRec.szRRN); //Terminal prints incorrect value of RRN for RTR Points Inquiry and RTR Redeem
    		sprintf(szTemp4, "HOST: %s", srTransRec.szHostLabel);		
		inPrintLeftRight(szTemp3, szTemp4, 46);

		// PRINT APPR CODE
		memset(szStr, 0x00, d_LINE_SIZE);
		sprintf(szStr, "APPR. CODE: %s", srTransRec.szAuthCode);
		result=inPrint(szStr);
		
#if 0
	    memset(szStr, 0x00, d_LINE_SIZE);
        sprintf(szStr, "REF NO.   : %s", srTransRec.szRRN);
	    result=inPrint(szStr);
	
	    memset(szStr, 0x00, d_LINE_SIZE);
        sprintf(szStr, "APPR. CODE: %s", srTransRec.szAuthCode);
	    result=inPrint(szStr);
        //Reference num
        if(strCDT.inType != DEBIT_CARD)
        {
            memset(szStr, ' ', d_LINE_SIZE);
            memset (baTemp, 0x00, sizeof(baTemp));					
            memset(szStr, ' ', d_LINE_SIZE);
            sprintf(szStr, "REF NO.   : %s", srTransRec.szRRN);
            memset (baTemp, 0x00, sizeof(baTemp));		
            CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
        }
		
		//Auth response code
		memset(szStr, ' ', d_LINE_SIZE);
		memset (baTemp, 0x00, sizeof(baTemp));					
		memset(szStr, ' ', d_LINE_SIZE);
		sprintf(szStr, "APPR. CODE: %s", srTransRec.szAuthCode);
		memset (baTemp, 0x00, sizeof(baTemp));		
		CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);


#endif

    	//printHostLabel(); // mfl	

        if(strTCT.fProductCode == TRUE)
        {
            memset(szStr, 0x00, d_LINE_SIZE);
            sprintf(szStr, "PRODUCT CODE: %s", srTransRec.szProductCode);
            result=inPrint(szStr);
        }

        if(strTCT.fCustomerNo == TRUE)
        {
	        memset(szStr, 0x00, d_LINE_SIZE);
            sprintf(szStr, "CUSTOMER NUMBER: %s", srTransRec.szCustomerNo);
	        result=inPrint(szStr);
        }

#if 1
	//Terminal serial number - mfl		
	memset(szTemp4, 0x00, sizeof(szTemp4));	
	memset(szTemp, ' ', d_LINE_SIZE);
    	memset (baTemp, 0x00, sizeof(baTemp));			
	memset(szTermSerialNum, 0x00, sizeof(szTermSerialNum)); 
	CTOS_GetFactorySN(szTermSerialNum);		 
			szTermSerialNum[15]=0;
	
	//sprintf(szStr, "TERMINAL SERIAL NUM: %s", szTermSerialNum);
	sprintf(szStr, "TSN: %s", szTermSerialNum);
	 
         CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
         result = CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
	//
#endif		
        //vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);
		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);	

		if(strHDT.fFooterLogo == TRUE)	
            vdCTOSS_PrinterBMPPic(0, 0, "footer.bmp");

        CTOS_PrinterFline(d_LINE_DOT * 1);
		CTOS_PrinterPutString("   ***** MERCHANT COPY *****  ");
	}
	else if(page == d_THIRD_PAGE)
	{
		memset(EMVtagVal, 0x00, sizeof(EMVtagVal));
		EMVtagLen = 0;
		
		DebugAddINT("ushCTOS_PrintFooter,mode",srTransRec.byEntryMode);  
		if(srTransRec.byEntryMode==CARD_ENTRY_ICC)
		{
			EMVtagLen = 3;
            		memcpy(EMVtagVal, srTransRec.stEMVinfo.T9F34, EMVtagLen);
			if((EMVtagVal[2]& 0x0F) == 2)
            		{         
                		CTOS_PrinterFline(d_LINE_DOT * 1);
                		CTOS_PrinterPutString("*****NO SIGNATURE REQUIRED*****");
                		CTOS_PrinterPutString("     (PIN VERIFY SUCCESS)");
            		}
            		else
            		{
				if((strCDT.inType != DEBIT_CARD) && (srTransRec.byTransType != LOY_BAL_INQ)) // mfl

				{
					CTOS_PrinterFline(d_LINE_DOT * 2);
					CTOS_PrinterPutString("SIGN:_______________________________________");
					TrimTrail(srTransRec.szCardholderName);
					vdPrintCenter(srTransRec.szCardholderName); 
				}
            		}
		}
        else
        {
			if((strCDT.inType != DEBIT_CARD) && (srTransRec.byTransType != LOY_BAL_INQ)) // mfl
			{
				CTOS_PrinterFline(d_LINE_DOT * 2);
				CTOS_PrinterPutString("SIGN:_______________________________________");
				TrimTrail(srTransRec.szCardholderName);
				vdPrintCenter(srTransRec.szCardholderName); 
			}
        }

        ushCTOS_ePadPrintSignature();
	
		CTOS_PrinterFline(d_LINE_DOT * 1);
		
		//ushCTOS_PrintAgreement();
		if(srTransRec.byTransType == LOY_BAL_INQ)	
		{	
	        	if(strlen(strMMT[0].szRctFoot1) > 0)
			vdPrintCenter(strMMT[0].szRctFoot1);
			if(strlen(strMMT[0].szRctFoot2) > 0)
		    	vdPrintCenter(strMMT[0].szRctFoot2);
			if(strlen(strMMT[0].szRctFoot3) > 0)
		    	vdPrintCenter(strMMT[0].szRctFoot3);
		}

		CTOS_PrinterFline(d_LINE_DOT * 1);

		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);	
		//vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);

		memset(szTemp, 0x00, sizeof(szTemp));
		memset(szTemp2, 0x00, sizeof(szTemp2));
		memset(szTemp3, 0x00, sizeof(szTemp3));
		memset(szTemp4, 0x00, sizeof(szTemp4));
		wub_hex_2_str(srTransRec.szDate, szTemp,DATE_BCD_SIZE);
		wub_hex_2_str(srTransRec.szTime, szTemp2,TIME_BCD_SIZE);
		memset(szTempDate, 0x00, sizeof(szTempDate));
		sprintf(szTempDate, "%02lu%02lu%02lu", atol(srTransRec.szYear), atol(szTemp)/100, atol(szTemp)%100);
		vdCTOS_FormatDate(szTempDate);
		sprintf(szTemp3, "DATE: %s", szTempDate);
		sprintf(szTemp4, "TIME: %02lu:%02lu:%02lu", atol(szTemp2)/10000,atol(szTemp2)%10000/100, atol(szTemp2)%100);
		inPrintLeftRight(szTemp3, szTemp4, 46);

		memset(szTemp, 0x00, sizeof(szTemp));
		memset(szTemp2, 0x00, sizeof(szTemp2));
		sprintf(szTemp, "TID: %s", srTransRec.szTID);
		sprintf(szTemp2, "MID: %s", srTransRec.szMID);
		inPrintLeftRight(szTemp, szTemp2, 46);

		memset(szTemp, 0x00, sizeof(szTemp));
		memset(szTemp2, 0x00, sizeof(szTemp2));
		memset(szTemp3, 0x00, sizeof(szTemp3));
		memset(szTemp4, 0x00, sizeof(szTemp4));
		wub_hex_2_str(srTransRec.szBatchNo,szTemp,3);
		wub_hex_2_str(srTransRec.szInvoiceNo, szTemp2, INVOICE_BCD_SIZE);
		sprintf(szTemp3, "BATCH NUM: %s", szTemp);
		sprintf(szTemp4, "TRACE NO.: %s", szTemp2);
		inPrintLeftRight(szTemp3, szTemp4, 46);


		// PRINT RRN AND HOST
		memset(szTemp, 0x00, sizeof(szTemp));
		memset(szTemp2, 0x00, sizeof(szTemp2));
		memset(szTemp3, 0x00, sizeof(szTemp3));
		memset(szTemp4, 0x00, sizeof(szTemp4));
		//wub_hex_2_str(srTransRec.szRRN,szTemp,3);
		//wub_hex_2_str(srTransRec.szHostLabel, szTemp2, INVOICE_BCD_SIZE);
            	sprintf(szTemp3, "REF NO.: %s", srTransRec.szRRN);//Terminal prints incorrect value of RRN for RTR Points Inquiry and RTR Redeem
		

		//sprintf(szTemp3, "REF NO.   : %s", szTemp);
		//sprintf(szTemp4, "  HOST     : %s", szTemp2);
    		sprintf(szTemp4, "HOST: %s", srTransRec.szHostLabel);		
		inPrintLeftRight(szTemp3, szTemp4, 46);

		// PRINT APPR CODE
		memset(szStr, 0x00, d_LINE_SIZE);
		sprintf(szStr, "APPR. CODE: %s", srTransRec.szAuthCode);
		result=inPrint(szStr);

#if 0
		memset(szStr, 0x00, d_LINE_SIZE);
		sprintf(szStr, "REF NO.   : %s", srTransRec.szRRN);
		result=inPrint(szStr);

		memset(szStr, 0x00, d_LINE_SIZE);
		sprintf(szStr, "APPR. CODE: %s", srTransRec.szAuthCode);
		result=inPrint(szStr);
        //Reference num
        if(strCDT.inType != DEBIT_CARD)
        {
            memset(szStr, ' ', d_LINE_SIZE);
            memset (baTemp, 0x00, sizeof(baTemp));					
            memset(szStr, ' ', d_LINE_SIZE);
            sprintf(szStr, "REF NO.   : %s", srTransRec.szRRN);
            memset (baTemp, 0x00, sizeof(baTemp));		
            CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
            CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);
        }
		
		//Auth response code
		memset(szStr, ' ', d_LINE_SIZE);
		memset (baTemp, 0x00, sizeof(baTemp));					
		memset(szStr, ' ', d_LINE_SIZE);
		sprintf(szStr, "APPR. CODE: %s", srTransRec.szAuthCode);
		memset (baTemp, 0x00, sizeof(baTemp));		
		CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		CTOS_PrinterBufferOutput((BYTE *)baTemp, 4);


#endif

    	//printHostLabel(); // mfl	

        if(strTCT.fProductCode == TRUE)
        {
            memset(szStr, 0x00, d_LINE_SIZE);
            sprintf(szStr, "PRODUCT CODE: %s", srTransRec.szProductCode);
            result=inPrint(szStr);
        }

        if(strTCT.fCustomerNo == TRUE)
        {
	        memset(szStr, 0x00, d_LINE_SIZE);
            sprintf(szStr, "CUSTOMER NUMBER: %s", srTransRec.szCustomerNo);
	        result=inPrint(szStr);
        }

#if 1
		//Terminal serial number - mfl		
		memset(szTemp4, 0x00, sizeof(szTemp4));	
		memset(szTemp, ' ', d_LINE_SIZE);
		memset (baTemp, 0x00, sizeof(baTemp));			
		memset(szTermSerialNum, 0x00, sizeof(szTermSerialNum)); 
		CTOS_GetFactorySN(szTermSerialNum);		 
			szTermSerialNum[15]=0;
		
		//sprintf(szStr, "TERMINAL SERIAL NUM: %s", szTermSerialNum);
	        sprintf(szStr, "TSN: %s", szTermSerialNum);
		
		CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		result = CTOS_PrinterBufferOutput((BYTE *)baTemp, 4); 
		//
#endif		
		//vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);
		vdSetGolbFontAttrib(d_FONT_16x16, NORMAL_SIZE, DOUBLE_SIZE, 0, 0);	

		if(strHDT.fFooterLogo == TRUE)	
		vdCTOSS_PrinterBMPPic(0, 0, "footer.bmp");

		CTOS_PrinterFline(d_LINE_DOT * 1);
		CTOS_PrinterPutString("   ***** BANK COPY *****  ");
	}

	CTOS_PrinterFline(d_LINE_DOT * 9); 
	
return d_OK;	

}

int inPrintISOPacket(BOOL fSendPacket, unsigned char *pucMessage, int inLen)
{
    char ucLineBuffer[d_LINE_SIZE];
    unsigned char *pucBuff;
    int inBuffPtr = 0;
    BYTE baTemp[PAPER_X_SIZE * 64];
    char szStr[d_LINE_SIZE + 1];
	

      if (inLen <= 0)
          return(ST_SUCCESS);


    inCTOS_SelectFont(d_FONT_FNT_MODE,d_FONT_24x24,0," ");
    vdSetGolbFontAttrib(d_FONT_24x24, NORMAL_SIZE, NORMAL_SIZE, 0, 0);

      if (fSendPacket)
      {
		memset (baTemp, 0x00, sizeof(baTemp));
		memset(szStr, 0x00, sizeof(szStr));
		strcpy(szStr,"Send ISO Packet\n");
		CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		CTOS_PrinterBufferOutput((BYTE *)baTemp, 3);

      }
      else
      {
		memset (baTemp, 0x00, sizeof(baTemp));	
		memset(szStr, 0x00, sizeof(szStr));
		strcpy(szStr,"Receive ISO Packet\n");

		CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, szStr, &stgFONT_ATTRIB);
		CTOS_PrinterBufferOutput((BYTE *)baTemp, 3);

      }
      
      CTOS_PrinterFline(d_LINE_DOT); 

      
      pucBuff = pucMessage + inLen;
      while (pucBuff > pucMessage)
      {
          memset(ucLineBuffer,0x00, sizeof(ucLineBuffer));
          for (inBuffPtr = 0; (inBuffPtr < 32) && (pucBuff > pucMessage); inBuffPtr += 3)
          {
              sprintf(&ucLineBuffer[inBuffPtr], "%02X ", *pucMessage);
              pucMessage++;
          }
              ucLineBuffer[32] = '\n';
		memset (baTemp, 0x00, sizeof(baTemp));		
		CTOS_PrinterBufferPutString((BYTE *)baTemp, 1, 1, ucLineBuffer, &stgFONT_ATTRIB);
		CTOS_PrinterBufferOutput((BYTE *)baTemp, 3);

      } 
      CTOS_PrinterFline(d_LINE_DOT * 2); 


      return (ST_SUCCESS);
}


/*
 * All leading spaces from a string is removed, string is a null terminated
 * string.
 */
void vdCTOSvdTrimLeadZeroes (char *pchString)

{
	int inIndex;

	inIndex = 0;
	while (pchString[inIndex] == '0')
		inIndex++;
	if (inIndex != 0)
		strcpy(pchString, &(pchString[inIndex]));
}

